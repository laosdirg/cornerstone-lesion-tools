{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///cornerstoneLesionTools.min.js","webpack:///webpack/bootstrap 05dd0bf15e8f7026ed35","webpack:///./externalModules.js","webpack:///./configuration.js","webpack:///./constants.js","webpack:///./lesionTools/history.js","webpack:///./index.js","webpack:///./lesionTools/display.js","webpack:///./lesionTools/threshold.js","webpack:///./lesionTools/grow.js","webpack:///./lesionTools/draw.js","webpack:///./util/pointInsidePolygon.js","webpack:///./lesionTools/score.js"],"names":["root","factory","exports","module","define","amd","self","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","value","cornerstoneTools","window","default","cst","cornerstone","external","cornerstoneMath","getConfiguration","configuration","setConfiguration","config","console","log","snap","historySize","layersAbove","layersBelow","historyPosition","toolRegionValue","calciumThresholdHu","drawAlpha","regionColorsRGB","KVPToMultiplier","150","140","130","120","110","100","90","80","70","growIterationsPerChunk","calciumThresholdHuParsed","parseInt","TYPED_ARRAY","Uint8Array","TOOL_TYPE","createUndoStep","element","thresholdingData","getToolState","state","data","current","buffer","slice","history","push","length","_configuration","shift","undo","replacement","pop","_externalModules2","updateImage","redo","_externalModules","obj","_interopRequireDefault","_display","_threshold","_grow","_draw","_score","_history","onImageRendered","_ref","detail","canvasContext","enabledElement","image","width","height","stackToolData","regionsToolData","drawBuffer","canvas","document","createElement","context","getContext","imageData","createImageData","currentImageIdIndex","_regionsToolData$data","doubleBuffer","pixels","sliceSize","sliceOffset","view","_constants","offset","imageDataOffset","label","color","putImageData","setToPixelCoordinateSystem","drawImage","_external$cornerstone","displayTool","lesionIndicator","performThresholding","imageIds","Promise","all","map","imageId","imageIdIndex","loadImage","then","ArrayBuffer","intercept","slope","pixelData","getPixelData","hu","ensureToolData","regionsData","enabled","addToolState","threshold","stackData","regions","linearNeighbours","highSlice","lowSlice","index","neighbours","sliceIndex","Math","floor","regionGrowing","point","_getConfiguration","_point","_slicedToArray","x","y","clickIndex","linearIndex","fromValue","resolve","activeVoxels","chunk","forEach","nextVoxels","reduce","acc","cur","concat","filter","indexOf","setTimeout","mouseDownCallback","e","_e$detail","currentPoints","which","options","getToolOptions","toolType","isMouseButtonEnabled","mouseButtonMask","_getToolState$data","_getToolState$data2","_currentPoints$image","round","sliceIterator","arr","_arr","_n","_d","_e","undefined","_s","_i","Symbol","iterator","next","done","err","Array","isArray","TypeError","simpleMouseButtonTool","updateRegions","numSlices","startSlice","max","endSlice","min","dslice","prevValue","snapBool","_pointInsidePolygon2","points","imageRenderedCallback","fillStyle","toolColors","getFillColor","strokeStyle","getActiveColor","beginPath","moveTo","lineTo","closePath","stroke","fill","dragCallback","_e$detail2","preventDefault","stopPropagation","mouseUpCallback","removeEventListener","_e$detail3","setToolOptions","addEventListener","_pointInsidePolygon","pointInsidePolygon","polygon","inside","j","_polygon$i","xi","yi","_polygon$j","xj","yj","_toConsumableArray","arr2","from","getDensityFactor","mode","array","modeMap","maxEl","maxCount","el","computeVoxelSize","metaData","sliceThickness","pixelSpacing","Error","computeScore","voxels","voxelSizeScaled","densityFactor","maxHU","volume","KVPMultiplier","KVP","cascore","modeOverlapFactor","computeIOPProjectedDistance","imagePositions","imageOrientation","imagePosition1Vector","Vector3","fromArray","imagePosition2Vector","imageOrientationRowVector","imageOrientationColumnVector","orientationNormal","crossVectors","projection1","projectOnVector","projection2","distanceTo","computeOverlapFactor","distance","bfs","visitedVoxels","lesionVoxels","stack","_stack$shift","_stack$shift2","score","_getConfiguration2","voxelsEachRegion","maxHUEachRegion","overlapFactor","prevImagePosition","overlapFactors","imageIndex","dataSet","floatString","string","split","parseFloat","rescaleSlope","rescaleIntercept","rescaleType","imagePositionPatient","imageOrientationTmp","apply","slicesInLabel","labelIdx","lesions","sliceIdx","lesionIdx","cascoreCurrent","val"],"mappings":"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","file":"cornerstoneLesionTools.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"cornerstoneLesionTools\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"cornerstoneLesionTools\"] = factory();\n\telse\n\t\troot[\"cornerstoneLesionTools\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","/*! cornerstone-lesion-tools - 0.1.0 - 2018-03-12 | (c) 2017 Chris Hafey | undefined */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"cornerstoneLesionTools\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"cornerstoneLesionTools\"] = factory();\n\telse\n\t\troot[\"cornerstoneLesionTools\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 4);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar cornerstoneTools = window.cornerstoneTools;\n\nexports.default = {\n  set cornerstoneTools(cst) {\n    cornerstoneTools = cst;\n  },\n  get cornerstoneTools() {\n    return cornerstoneTools;\n  },\n  get cornerstone() {\n    return cornerstoneTools.external.cornerstone;\n  },\n  get cornerstoneMath() {\n    return cornerstoneTools.external.cornerstoneMath;\n  }\n};\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getConfiguration = getConfiguration;\nexports.setConfiguration = setConfiguration;\nvar configuration = {\n  snap: false, // Snap to thresholded region or not\n  historySize: 4,\n  layersAbove: 1,\n  layersBelow: 1,\n  historyPosition: 0,\n  toolRegionValue: 2,\n  calciumThresholdHu: '-', // Placeholder until it gets set ('-' shows up nicely in text input)\n  drawAlpha: 1,\n  regionColorsRGB: [[255, 0, 255], [246, 193, 91], [237, 148, 69], [230, 103, 49], [184, 74, 41], [106, 58, 45]],\n  KVPToMultiplier: {\n    150: 1.06,\n    140: 1.04,\n    130: 1.02,\n    120: 1,\n    110: 0.98,\n    100: 0.96,\n    90: 0.93,\n    80: 0.89,\n    70: 0.85\n  },\n  growIterationsPerChunk: 2\n};\n\nconfiguration.calciumThresholdHuParsed = parseInt(configuration.calciumThresholdHu, 10);\n\nfunction getConfiguration() {\n  return configuration;\n}\n\nfunction setConfiguration(config) {\n  console.log(\"c\", config);\n  configuration = config;\n}\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar TYPED_ARRAY = exports.TYPED_ARRAY = Uint8Array;\nvar TOOL_TYPE = exports.TOOL_TYPE = 'regions';\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createUndoStep = createUndoStep;\nexports.undo = undo;\nexports.redo = redo;\n\nvar _externalModules = __webpack_require__(0);\n\nvar _externalModules2 = _interopRequireDefault(_externalModules);\n\nvar _configuration = __webpack_require__(1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar getToolState = _externalModules2.default.cornerstoneTools.getToolState;\n\n/**\n * Store current state to history\n */\n\nfunction createUndoStep(element) {\n  var thresholdingData = getToolState(element, 'regions');\n\n  var state = thresholdingData.data[0];\n  // Make a copy using .slice()\n  var current = state.buffer.slice();\n\n  // Put at end of history\n  state.history.push(current);\n  // Remove oldest if too much history\n  if (state.history.length > (0, _configuration.getConfiguration)().historySize) {\n    state.history.shift();\n  }\n}\n\nfunction undo(element) {\n  var thresholdingData = getToolState(element, 'regions');\n  var state = thresholdingData.data[0];\n\n  if (state.history.length < 1) {\n    return;\n  }\n\n  var replacement = state.history.pop();\n\n  state.buffer = replacement;\n  _externalModules2.default.cornerstone.updateImage(element);\n}\n\nfunction redo() {\n  // Not implemented\n}\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _externalModules = __webpack_require__(0);\n\nObject.defineProperty(exports, 'external', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_externalModules).default;\n  }\n});\n\nvar _configuration = __webpack_require__(1);\n\nObject.defineProperty(exports, 'getConfiguration', {\n  enumerable: true,\n  get: function get() {\n    return _configuration.getConfiguration;\n  }\n});\nObject.defineProperty(exports, 'setConfiguration', {\n  enumerable: true,\n  get: function get() {\n    return _configuration.setConfiguration;\n  }\n});\n\nvar _display = __webpack_require__(5);\n\nObject.defineProperty(exports, 'display', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_display).default;\n  }\n});\n\nvar _threshold = __webpack_require__(6);\n\nObject.defineProperty(exports, 'threshold', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_threshold).default;\n  }\n});\n\nvar _grow = __webpack_require__(7);\n\nObject.defineProperty(exports, 'grow', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_grow).default;\n  }\n});\n\nvar _draw = __webpack_require__(8);\n\nObject.defineProperty(exports, 'draw', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_draw).default;\n  }\n});\n\nvar _score = __webpack_require__(10);\n\nObject.defineProperty(exports, 'score', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_score).default;\n  }\n});\n\nvar _history = __webpack_require__(3);\n\nObject.defineProperty(exports, 'undo', {\n  enumerable: true,\n  get: function get() {\n    return _history.undo;\n  }\n});\nObject.defineProperty(exports, 'redo', {\n  enumerable: true,\n  get: function get() {\n    return _history.redo;\n  }\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _externalModules = __webpack_require__(0);\n\nvar _externalModules2 = _interopRequireDefault(_externalModules);\n\nvar _constants = __webpack_require__(2);\n\nvar _configuration = __webpack_require__(1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _external$cornerstone = _externalModules2.default.cornerstoneTools,\n    displayTool = _external$cornerstone.displayTool,\n    getToolState = _external$cornerstone.getToolState;\n\n/**\n * Draw regions on image\n */\n\nfunction onImageRendered(_ref) {\n  var detail = _ref.detail;\n\n  var configuration = (0, _configuration.getConfiguration)();\n  var canvasContext = detail.canvasContext,\n      element = detail.element,\n      enabledElement = detail.enabledElement,\n      image = detail.image;\n  var width = image.width,\n      height = image.height;\n\n\n  var stackToolData = getToolState(element, 'stack');\n  var regionsToolData = getToolState(element, 'regions');\n\n  // Ensure tool is enabled\n  if (!regionsToolData || !regionsToolData.data || !regionsToolData.data.length) {\n    return;\n  }\n\n  if (!regionsToolData.data[0].drawBuffer || width !== regionsToolData.data[0].drawBuffer.canvas.width) {\n    var canvas = document.createElement('canvas');\n    var context = canvas.getContext('2d');\n    var _imageData = context.createImageData(width, height);\n\n    canvas.width = width;\n    canvas.height = height;\n\n    regionsToolData.data[0].drawBuffer = {\n      canvas: canvas,\n      imageData: _imageData\n    };\n  }\n\n  // Extract tool data\n  var currentImageIdIndex = stackToolData.data[0].currentImageIdIndex;\n  var _regionsToolData$data = regionsToolData.data[0],\n      drawBuffer = _regionsToolData$data.drawBuffer,\n      buffer = _regionsToolData$data.buffer;\n\n\n  var doubleBuffer = drawBuffer.canvas;\n  var imageData = drawBuffer.imageData;\n\n  var pixels = imageData.data;\n  var sliceSize = width * height;\n  var sliceOffset = currentImageIdIndex * sliceSize;\n  var view = new _constants.TYPED_ARRAY(buffer, sliceOffset, sliceSize);\n\n  for (var offset = 0; offset < view.length; offset += 1) {\n    // Each pixel is represented by four elements in the imageData array\n    var imageDataOffset = offset * 4;\n    var label = view[offset];\n\n    if (label) {\n      var color = configuration.regionColorsRGB[label - 1];\n\n      pixels[imageDataOffset + 0] = color[0];\n      pixels[imageDataOffset + 1] = color[1];\n      pixels[imageDataOffset + 2] = color[2];\n      pixels[imageDataOffset + 3] = configuration.drawAlpha * 255;\n    } else {\n      pixels[imageDataOffset + 3] = 0;\n    }\n  }\n\n  // Put image data back into offscreen canvas\n  doubleBuffer.getContext('2d').putImageData(imageData, 0, 0);\n  // Set transforms based on zoom/pan/etc\n  _externalModules2.default.cornerstone.setToPixelCoordinateSystem(enabledElement, canvasContext);\n  // Finally, draw offscreen canvas onto context\n  canvasContext.drawImage(doubleBuffer, 0, 0);\n}\n\nvar lesionIndicator = displayTool(onImageRendered);\n\nexports.default = lesionIndicator;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _externalModules = __webpack_require__(0);\n\nvar _externalModules2 = _interopRequireDefault(_externalModules);\n\nvar _constants = __webpack_require__(2);\n\nvar _configuration = __webpack_require__(1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _external$cornerstone = _externalModules2.default.cornerstoneTools,\n    addToolState = _external$cornerstone.addToolState,\n    getToolState = _external$cornerstone.getToolState;\n\n/**\n * Perform the thresholding on a stack\n */\n\nfunction performThresholding(imageIds) {\n  var width = void 0,\n      height = void 0,\n      view = void 0,\n      buffer = void 0;\n\n  var configuration = (0, _configuration.getConfiguration)();\n\n  // Thresholding promises\n  return Promise.all(imageIds.map(function (imageId, imageIdIndex) {\n    return _externalModules2.default.cornerstone.loadImage(imageId).then(function (image) {\n      if (!buffer) {\n        // Initialize variables on first loaded image\n        width = image.width;\n        height = image.height;\n\n        var length = width * height * imageIds.length;\n\n        buffer = new ArrayBuffer(length);\n        view = new _constants.TYPED_ARRAY(buffer);\n      }\n\n      var intercept = image.intercept,\n          slope = image.slope;\n\n      var pixelData = image.getPixelData();\n      var sliceSize = width * height;\n\n      for (var i = 0; i < sliceSize; i++) {\n        var value = pixelData[i];\n        // Calculate hu-value\n        var hu = value * slope + intercept;\n        // Check against threshold\n        var label = hu >= configuration.calciumThresholdHu ? 1 : 0;\n        // Calculate offset within view into ArrayBufer\n        var offset = imageIdIndex * sliceSize + i;\n\n        // Finally, assign label\n        view[offset] = label;\n      }\n    });\n  }\n  // When all promises resolve, return the buffer and its dimensions\n  )).then(function () {\n    return {\n      buffer: buffer,\n      width: width,\n      height: height\n    };\n  });\n}\n\nfunction ensureToolData(element) {\n  var regionsData = void 0;\n\n  var regionsToolData = getToolState(element, _constants.TOOL_TYPE);\n\n  if (!regionsToolData || !regionsToolData.data || !regionsToolData.data.length) {\n    regionsData = {\n      enabled: 1,\n      buffer: null,\n      width: null,\n      height: null,\n      history: [],\n      drawBuffer: null\n    };\n    addToolState(element, _constants.TOOL_TYPE, regionsData);\n  } else {\n    regionsData = regionsToolData.data[0];\n  }\n\n  return regionsData;\n}\n\nfunction threshold(element) {\n  var stackToolData = getToolState(element, 'stack');\n\n  if (!stackToolData || !stackToolData.data || !stackToolData.data.length) {\n    return;\n  }\n\n  var stackData = stackToolData.data[0];\n  var regionsData = ensureToolData(element);\n\n  performThresholding(stackData.imageIds).then(function (regions) {\n    // Add threshold data to tool state\n    regionsData.buffer = regions.buffer;\n    regionsData.width = regions.width;\n    regionsData.height = regions.height;\n\n    // Update the element to apply the viewport and tool changes\n    _externalModules2.default.cornerstone.updateImage(element);\n  });\n}\n// Module/private exports\nexports.default = threshold;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _externalModules = __webpack_require__(0);\n\nvar _externalModules2 = _interopRequireDefault(_externalModules);\n\nvar _history = __webpack_require__(3);\n\nvar _configuration = __webpack_require__(1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _external$cornerstone = _externalModules2.default.cornerstoneTools,\n    getToolState = _external$cornerstone.getToolState,\n    simpleMouseButtonTool = _external$cornerstone.simpleMouseButtonTool,\n    isMouseButtonEnabled = _external$cornerstone.isMouseButtonEnabled,\n    getToolOptions = _external$cornerstone.getToolOptions;\n\n\nvar toolType = 'regionsGrow';\n\n// Get neighbour linear indices within slice bounds\nfunction linearNeighbours(width, height, highSlice, lowSlice, index) {\n  var sliceSize = width * height;\n  var neighbours = [index - 1, index + 1, index - width, index + width];\n\n  // Stay within bounds\n  var sliceIndex = Math.floor(index / sliceSize);\n\n  if (sliceIndex < highSlice) {\n    neighbours.push(index + sliceSize);\n  }\n  if (sliceIndex > lowSlice) {\n    neighbours.push(index - sliceSize);\n  }\n\n  return neighbours;\n}\n\nfunction regionGrowing(regions, point) {\n  var _getConfiguration = (0, _configuration.getConfiguration)(),\n      growIterationsPerChunk = _getConfiguration.growIterationsPerChunk,\n      toolRegionValue = _getConfiguration.toolRegionValue,\n      layersAbove = _getConfiguration.layersAbove,\n      layersBelow = _getConfiguration.layersBelow;\n\n  var width = regions.width,\n      height = regions.height,\n      buffer = regions.buffer;\n\n  var _point = _slicedToArray(point, 3),\n      x = _point[0],\n      y = _point[1],\n      slice = _point[2];\n\n  var highSlice = slice + layersBelow;\n  var lowSlice = slice - layersAbove;\n\n  var view = new Uint8Array(buffer);\n\n  // Calculate linear indices and offsets\n  var sliceSize = width * height;\n  var sliceOffset = sliceSize * slice;\n  var clickIndex = y * width + x;\n  var linearIndex = sliceOffset + clickIndex;\n  var fromValue = view[linearIndex];\n\n  // Only continue if we clicked in thresholded area in different color\n  if (fromValue === 0 || fromValue === toolRegionValue) {\n    return Promise.resolve();\n  }\n\n  // Growing starts at clicked voxel\n  var activeVoxels = [linearIndex];\n\n  return new Promise(function (resolve) {\n    function chunk() {\n      for (var i = 0; i < growIterationsPerChunk; i++) {\n        // While activeVoxels is not empty\n        if (activeVoxels.length === 0) {\n          return resolve();\n        }\n\n        // Set the active voxels to nextValue\n        activeVoxels.forEach(function (i) {\n          view[i] = toolRegionValue;\n        });\n\n        // The new active voxels are neighbours of curent active voxels\n        var nextVoxels = activeVoxels.map(function (i) {\n          return linearNeighbours(width, height, highSlice, lowSlice, i);\n        }).reduce( // Flatten the array of arrays to array of indices\n        function (acc, cur) {\n          return acc.concat(cur);\n        }, []).filter( // Remove duplicates\n        function (value, index, self) {\n          return self.indexOf(value) === index;\n        }).filter( // Remove voxels that does not have the correct fromValue\n        function (i) {\n          return view[i] === fromValue;\n        });\n\n        activeVoxels = nextVoxels;\n      }\n      setTimeout(chunk, 0);\n    }\n\n    chunk();\n  });\n}\n\nfunction mouseDownCallback(e) {\n  var _e$detail = e.detail,\n      currentPoints = _e$detail.currentPoints,\n      element = _e$detail.element,\n      which = _e$detail.which;\n\n  var options = getToolOptions(toolType, element);\n\n  if (isMouseButtonEnabled(which, options.mouseButtonMask)) {\n    var _getToolState$data = _slicedToArray(getToolState(element, 'stack').data, 1),\n        stackData = _getToolState$data[0];\n\n    var _getToolState$data2 = _slicedToArray(getToolState(element, 'regions').data, 1),\n        regionsData = _getToolState$data2[0];\n\n    var currentImageIdIndex = stackData.currentImageIdIndex;\n    var _currentPoints$image = currentPoints.image,\n        x = _currentPoints$image.x,\n        y = _currentPoints$image.y;\n\n    var point = [Math.round(x), Math.round(y), currentImageIdIndex];\n\n    (0, _history.createUndoStep)(element);\n    regionGrowing(regionsData, point).then(function () {\n      _externalModules2.default.cornerstone.updateImage(element);\n    });\n  }\n}\n\nexports.default = simpleMouseButtonTool(mouseDownCallback, toolType);\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _externalModules = __webpack_require__(0);\n\nvar _externalModules2 = _interopRequireDefault(_externalModules);\n\nvar _pointInsidePolygon = __webpack_require__(9);\n\nvar _pointInsidePolygon2 = _interopRequireDefault(_pointInsidePolygon);\n\nvar _configuration = __webpack_require__(1);\n\nvar _history = __webpack_require__(3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _external$cornerstone = _externalModules2.default.cornerstoneTools,\n    toolColors = _external$cornerstone.toolColors,\n    getToolState = _external$cornerstone.getToolState,\n    getToolOptions = _external$cornerstone.getToolOptions,\n    setToolOptions = _external$cornerstone.setToolOptions,\n    simpleMouseButtonTool = _external$cornerstone.simpleMouseButtonTool,\n    isMouseButtonEnabled = _external$cornerstone.isMouseButtonEnabled;\n\n\nvar toolType = 'draw';\n\nfunction updateRegions(element) {\n  var _getConfiguration = (0, _configuration.getConfiguration)(),\n      snap = _getConfiguration.snap,\n      toolRegionValue = _getConfiguration.toolRegionValue,\n      layersAbove = _getConfiguration.layersAbove,\n      layersBelow = _getConfiguration.layersBelow;\n\n  (0, _history.createUndoStep)(element);\n\n  // Get tool data\n  var stackData = getToolState(element, 'stack');\n  var thresholdingData = getToolState(element, 'regions');\n  var options = getToolOptions(toolType, element);\n\n  // Extract tool data\n  var slice = stackData.data[0].currentImageIdIndex;\n  var numSlices = stackData.data[0].imageIds.length;\n  var regions = thresholdingData.data[0];\n\n  // Extract region data\n  var buffer = regions.buffer;\n  var width = regions.width;\n  var height = regions.height;\n\n  // Find operation bounds\n  var startSlice = Math.max(0, slice - layersAbove);\n  var endSlice = Math.min(numSlices, slice + layersBelow);\n\n  // Setup view into buffer\n  var sliceSize = width * height;\n  var sliceOffset = startSlice * sliceSize;\n  var view = new Uint8Array(buffer, sliceOffset);\n\n  // Mark points inside\n  for (var dslice = 0; dslice <= endSlice - startSlice; dslice += 1) {\n    for (var x = 0; x < width; x += 1) {\n      for (var y = 0; y < height; y += 1) {\n        var index = x + y * width + dslice * sliceSize;\n        var prevValue = view[index];\n\n        var snapBool = void 0;\n\n        if (snap) {\n          snapBool = prevValue > 0;\n        } else {\n          snapBool = true;\n        }\n        var point = {\n          x: x,\n          y: y\n        };\n\n        if (snapBool && (0, _pointInsidePolygon2.default)(point, options.points)) {\n          view[index] = toolRegionValue;\n        }\n      }\n    }\n  }\n}\n\n// Draw regions on the canvas\nfunction imageRenderedCallback(e) {\n  var _e$detail = e.detail,\n      canvasContext = _e$detail.canvasContext,\n      enabledElement = _e$detail.enabledElement,\n      element = _e$detail.element;\n\n  // Points\n\n  var options = getToolOptions(toolType, element);\n  var points = options.points;\n\n  if (points.length < 2) {\n    return;\n  }\n\n  // Set the canvas context to the image coordinate system\n  _externalModules2.default.cornerstone.setToPixelCoordinateSystem(enabledElement, canvasContext);\n\n  canvasContext.fillStyle = toolColors.getFillColor();\n  canvasContext.strokeStyle = toolColors.getActiveColor();\n  canvasContext.beginPath();\n  canvasContext.moveTo(points[0].x, points[0].y);\n  points.slice(1).forEach(function (point) {\n    canvasContext.lineTo(point.x, point.y);\n  });\n  canvasContext.closePath();\n  canvasContext.stroke();\n  canvasContext.fill();\n}\n\nfunction dragCallback(e) {\n  var _e$detail2 = e.detail,\n      currentPoints = _e$detail2.currentPoints,\n      element = _e$detail2.element;\n\n  var options = getToolOptions(toolType, element);\n\n  options.points.push(currentPoints.image);\n  _externalModules2.default.cornerstone.updateImage(element);\n\n  e.preventDefault();\n  e.stopPropagation();\n}\n\n// Disable drawing and tracking on mouse up also update regions\nfunction mouseUpCallback(e) {\n  var element = e.detail.element;\n\n\n  element.removeEventListener('cornerstonetoolsmousedrag', dragCallback);\n  element.removeEventListener('cornerstonetoolsmouseup', mouseUpCallback);\n  element.removeEventListener('cornerstonetoolsmouseclick', mouseUpCallback);\n  element.removeEventListener('cornerstoneimagerendered', imageRenderedCallback);\n\n  updateRegions(element);\n  _externalModules2.default.cornerstone.updateImage(element);\n}\n\n// Start drawing and tracking on mouse up, also reset points array\nfunction mouseDownCallback(e) {\n  var _e$detail3 = e.detail,\n      element = _e$detail3.element,\n      which = _e$detail3.which;\n\n  var options = getToolOptions(toolType, element);\n\n  if (isMouseButtonEnabled(which, options.mouseButtonMask)) {\n    options.points = [];\n\n    setToolOptions(toolType, element, options);\n\n    element.addEventListener('cornerstonetoolsmousedrag', dragCallback);\n    element.addEventListener('cornerstonetoolsmouseup', mouseUpCallback);\n    element.addEventListener('cornerstonetoolsmouseclick', mouseUpCallback);\n    element.addEventListener('cornerstoneimagerendered', imageRenderedCallback);\n\n    e.preventDefault();\n    e.stopPropagation();\n  }\n}\n\nexports.default = simpleMouseButtonTool(mouseDownCallback, toolType);\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = pointInsidePolygon;\n// Determine if a point is inside a polygon\nfunction pointInsidePolygon(point, polygon) {\n  var x = point.x,\n      y = point.y;\n\n  var n = polygon.length;\n  var inside = false;\n\n  for (var i = 0, j = n - 1; i < n; j = i++) {\n    var _polygon$i = polygon[i],\n        xi = _polygon$i.x,\n        yi = _polygon$i.y;\n    var _polygon$j = polygon[j],\n        xj = _polygon$j.x,\n        yj = _polygon$j.y;\n\n\n    var intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;\n\n    if (intersect) {\n      inside = !inside;\n    }\n  }\n\n  return inside;\n}\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nexports.computeVoxelSize = computeVoxelSize;\nexports.computeScore = computeScore;\nexports.computeIOPProjectedDistance = computeIOPProjectedDistance;\nexports.computeOverlapFactor = computeOverlapFactor;\nexports.score = score;\n\nvar _externalModules = __webpack_require__(0);\n\nvar _externalModules2 = _interopRequireDefault(_externalModules);\n\nvar _configuration = __webpack_require__(1);\n\nvar _constants = __webpack_require__(2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar getToolState = _externalModules2.default.cornerstoneTools.getToolState;\n\n\nfunction getDensityFactor(hu) {\n  if (hu < 130) {\n    return 0;\n  } else if (hu < 200) {\n    return 1;\n  } else if (hu < 300) {\n    return 2;\n  } else if (hu < 400) {\n    return 3;\n  }\n\n  return 4;\n}\n\n// Finds the value with the most occurrences in array\n// Should be O(n)\nfunction mode(array) {\n  if (array.length === 0) {\n    return null;\n  }\n  var modeMap = {};\n  var maxEl = array[0];\n  var maxCount = 1;\n\n  for (var i = 0; i < array.length; i++) {\n    var el = array[i];\n\n    if (modeMap[el] === null) {\n      modeMap[el] = 1;\n    } else {\n      modeMap[el]++;\n    }\n\n    if (modeMap[el] > maxCount) {\n      maxEl = el;\n      maxCount = modeMap[el];\n    }\n  }\n\n  return maxEl;\n}\n\nfunction computeVoxelSize(metaData) {\n  if (metaData.sliceThickness === 0 || metaData.pixelSpacing[0] === 0 || metaData.pixelSpacing[1] === 0) {\n    throw new Error('sliceThickness or pixelSpacing was 0');\n  }\n  var zLength = metaData.sliceThickness;\n  var xLength = metaData.pixelSpacing[0];\n  var yLength = metaData.pixelSpacing[1];\n\n  return zLength * xLength * yLength; // In mm\n}\n\nfunction computeScore(metaData, voxels) {\n  // Division by 3 because Agatson score assumes a slice thickness of 3 mm\n  var voxelSizeScaled = computeVoxelSize(metaData) / 3;\n  var densityFactor = getDensityFactor(metaData.maxHU);\n  var volume = voxels.length * voxelSizeScaled;\n\n  var _getConfiguration = (0, _configuration.getConfiguration)(),\n      KVPToMultiplier = _getConfiguration.KVPToMultiplier;\n\n  var KVPMultiplier = KVPToMultiplier[metaData.KVP];\n  var cascore = volume * densityFactor * KVPMultiplier;\n\n  /*\n   console.log(`modeOverlapFactor: ${metaData.modeOverlapFactor}`);\n   console.log(`voxels.length: ${voxels.length}`);\n   console.log(`voxelSizeScaled: ${voxelSizeScaled}`);\n   console.log(`Volume: ${volume}`);\n   console.log(`Max HU: ${metaData.maxHU}`);\n   console.log(`densityFactor: ${densityFactor}`);\n   console.log(`KVPMultiplier: ${KVPMultiplier}`);\n   console.log(`CAscore: ${cascore}`); */\n\n  // If modeOverlapFactor factor is undefined it is because there is only one slice in the series.\n  // In this case obviously modeOverlapFactor is meaningless and should not be multiplied with cascore.\n  if (metaData.modeOverlapFactor) {\n    return cascore * metaData.modeOverlapFactor;\n  }\n\n  return cascore;\n}\n\n/*\n* Computes the distance between two slices based on the DICOM Image Plane Module\n* @param imagePositions {Array[2][3]} - DICOM tag (0020, 0032) of two slices\n* @param imageOrientation {Array[2][3]} - DICOM tag (0020, 0037) of first slice\n*/\nfunction computeIOPProjectedDistance(imagePositions, imageOrientation) {\n  var imagePosition1Vector = new _externalModules2.default.cornerstoneMath.Vector3();\n\n  imagePosition1Vector.fromArray(imagePositions[0]);\n\n  var imagePosition2Vector = new _externalModules2.default.cornerstoneMath.Vector3();\n\n  imagePosition2Vector.fromArray(imagePositions[1]);\n\n  var imageOrientationRowVector = new _externalModules2.default.cornerstoneMath.Vector3();\n\n  imageOrientationRowVector.fromArray(imageOrientation[0]);\n\n  var imageOrientationColumnVector = new _externalModules2.default.cornerstoneMath.Vector3();\n\n  imageOrientationColumnVector.fromArray(imageOrientation[1]);\n\n  // Compute unit normal of Image Orientation crossVectors\n  var orientationNormal = new _externalModules2.default.cornerstoneMath.Vector3();\n\n  orientationNormal.crossVectors(imageOrientationRowVector, imageOrientationColumnVector);\n  // Project both position vectors on normal\n  var projection1 = imagePosition1Vector.projectOnVector(orientationNormal);\n  var projection2 = imagePosition2Vector.projectOnVector(orientationNormal);\n\n  // Compute distance of projected vectors\n  return projection1.distanceTo(projection2);\n}\n\nfunction computeOverlapFactor(distance, sliceThickness) {\n  if (distance <= 0) {\n    throw new Error('Distance must be > 0');\n  }\n\n  if (distance >= sliceThickness) {\n    return 1;\n  }\n\n  var overlap = sliceThickness - distance;\n\n  return (sliceThickness - overlap) / sliceThickness;\n}\n\nfunction bfs(x, y, view, visitedVoxels, label, image) {\n  var intercept = image.intercept,\n      slope = image.slope,\n      width = image.width;\n\n  var pixelData = image.getPixelData();\n  var lesionVoxels = [];\n  var stack = [[x, y]];\n\n  while (stack.length > 0) {\n    var _stack$shift = stack.shift(),\n        _stack$shift2 = _slicedToArray(_stack$shift, 2),\n        _x = _stack$shift2[0],\n        _y = _stack$shift2[1];\n\n    // If visited is 0, the element has not been visisted before\n\n\n    if (visitedVoxels[_x][_y] === 0 && view[_y * width + _x] === label) {\n      stack.push([_x - 1, _y]);\n      stack.push([_x + 1, _y]);\n      stack.push([_x, _y - 1]);\n      stack.push([_x, _y + 1]);\n\n      var value = pixelData[_x + _y * width];\n      var hu = value * slope + intercept;\n\n      if (hu >= 130) {\n        lesionVoxels.push(hu);\n      }\n      visitedVoxels[_x][_y] = 1;\n    }\n  }\n\n  return lesionVoxels;\n}\n\n/**\n * Calculate CaScore per label per slice per lesion\n *\n */\nfunction score(element) {\n  var _getConfiguration2 = (0, _configuration.getConfiguration)(),\n      regionColorsRGB = _getConfiguration2.regionColorsRGB;\n\n  var regionsToolData = getToolState(element, _constants.TOOL_TYPE);\n  var stackToolData = getToolState(element, 'stack');\n  var buffer = regionsToolData.data[0].buffer;\n  var imageIds = stackToolData.data[0].imageIds;\n\n  // Extract and group region-voxels\n\n  var voxelsEachRegion = regionColorsRGB.slice(1).map(function () {\n    return imageIds.map(function () {\n      return [];\n    });\n  });\n  var maxHUEachRegion = regionColorsRGB.slice(1).map(function () {\n    return imageIds.map(function () {\n      return [];\n    });\n  });\n\n  var overlapFactor = void 0;\n  var prevImagePosition = void 0;\n  var overlapFactors = [];\n\n  var metaData = {};\n\n  return Promise.all(imageIds.map(function (imageId, imageIndex) {\n    return _externalModules2.default.cornerstone.loadImage(imageId).then(function (image) {\n      var dataSet = image.data;\n\n      metaData.sliceThickness = dataSet.floatString('x00180050');\n      metaData.pixelSpacing = dataSet.string('x00280030').split('\\\\').map(parseFloat);\n      metaData.KVP = dataSet.floatString('x00180060');\n      metaData.rescaleSlope = dataSet.floatString('x00281053');\n      metaData.rescaleIntercept = dataSet.floatString('x00281052');\n      metaData.rescaleType = dataSet.string('x00281054');\n\n      var imagePositionPatient = dataSet.string('x00200032').split('\\\\').map(parseFloat);\n      var imageOrientationTmp = dataSet.string('x00200037').split('\\\\').map(parseFloat);\n      var imageOrientation = [imageOrientationTmp.slice(0, 3), imageOrientationTmp.slice(3)];\n\n      /* What is this?\n       if (metaData.rescaleType !== 'HU') {\n         console.warn(`Modality LUT does not convert to Hounsfield units but to ${metaData.rescaleType}. Agatston score is not defined for this unit type.`);\n          return;\n      }\n       */\n\n      if (prevImagePosition) {\n        var distance = computeIOPProjectedDistance([prevImagePosition, imagePositionPatient], imageOrientation);\n\n        overlapFactor = computeOverlapFactor(distance, metaData.sliceThickness);\n\n        // Find overlapfactor with the highest occurance\n        overlapFactors.push(overlapFactor);\n        metaData.modeOverlapFactor = mode(overlapFactors);\n\n        // Save imagePositionPatient for next overlapFactor computation\n        prevImagePosition = imagePositionPatient;\n      } else {\n        prevImagePosition = imagePositionPatient;\n      }\n\n      // Overlap has been calculated, now we investigate voxels\n\n      var height = image.height,\n          width = image.width;\n\n      var sliceSize = width * height;\n      var offset = imageIndex * sliceSize;\n\n      var view = new _constants.TYPED_ARRAY(buffer, offset, sliceSize);\n\n      // Initialze with 0's\n      var visitedVoxels = Array(width).fill().map(function () {\n        return Array(height).fill(0);\n      });\n\n      for (var x = 0; x < width; x += 1) {\n        for (var y = 0; y < height; y += 1) {\n          // Extract label from view into ArrayBuffer\n          var label = view[y * width + x];\n\n          if (label > 1) {\n            var lesionVoxels = bfs(x, y, view, visitedVoxels, label, image);\n\n            if (lesionVoxels.length) {\n              var maxHU = Math.max.apply(Math, _toConsumableArray(lesionVoxels));\n\n              voxelsEachRegion[label - 2][imageIndex].push(lesionVoxels);\n              maxHUEachRegion[label - 2][imageIndex].push(maxHU);\n            }\n          }\n        }\n      }\n    });\n  }\n  // When all images have been processed\n  )).then(function () {\n    return voxelsEachRegion.map(function (slicesInLabel, labelIdx) {\n      var cascore = [];\n\n      slicesInLabel.forEach(function (lesions, sliceIdx) {\n        lesions.forEach(function (voxels, lesionIdx) {\n          metaData.maxHU = maxHUEachRegion[labelIdx][sliceIdx][lesionIdx];\n\n          var cascoreCurrent = voxels.length > 0 ? computeScore(metaData, voxels) : 0;\n\n          cascore.push(cascoreCurrent);\n        });\n      });\n      var sum = cascore.reduce(function (acc, val) {\n        return acc + val;\n      }, 0);\n\n      return sum;\n    });\n  });\n}\n\nexports.default = score;\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// cornerstoneLesionTools.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 05dd0bf15e8f7026ed35","let cornerstoneTools = window.cornerstoneTools;\n\nexport default {\n  set cornerstoneTools (cst) {\n    cornerstoneTools = cst;\n  },\n  get cornerstoneTools () {\n    return cornerstoneTools;\n  },\n  get cornerstone () {\n    return cornerstoneTools.external.cornerstone;\n  },\n  get cornerstoneMath () {\n    return cornerstoneTools.external.cornerstoneMath;\n  }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./externalModules.js","let configuration = {\n  snap: false, // Snap to thresholded region or not\n  historySize: 4,\n  layersAbove: 1,\n  layersBelow: 1,\n  historyPosition: 0,\n  toolRegionValue: 2,\n  calciumThresholdHu: '-', // Placeholder until it gets set ('-' shows up nicely in text input)\n  drawAlpha: 1,\n  regionColorsRGB: [\n    [255, 0, 255],\n    [246, 193, 91],\n    [237, 148, 69],\n    [230, 103, 49],\n    [184, 74, 41],\n    [106, 58, 45]\n  ],\n  KVPToMultiplier: {\n    150: 1.06,\n    140: 1.04,\n    130: 1.02,\n    120: 1,\n    110: 0.98,\n    100: 0.96,\n    90: 0.93,\n    80: 0.89,\n    70: 0.85\n  },\n  growIterationsPerChunk: 2\n};\n\nconfiguration.calciumThresholdHuParsed = parseInt(configuration.calciumThresholdHu, 10);\n\nexport function getConfiguration () {\n  return configuration;\n}\n\nexport function setConfiguration (config) {\n  console.log(\"c\", config);\n  configuration = config;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./configuration.js","export const TYPED_ARRAY = Uint8Array;\nexport const TOOL_TYPE = 'regions';\n\n\n\n// WEBPACK FOOTER //\n// ./constants.js","import external from '../externalModules.js';\nimport { getConfiguration } from '../configuration.js';\n\nconst { getToolState } = external.cornerstoneTools;\n\n/**\n * Store current state to history\n */\nexport function createUndoStep (element) {\n  const thresholdingData = getToolState(element, 'regions');\n\n  const state = thresholdingData.data[0];\n  // Make a copy using .slice()\n  const current = state.buffer.slice();\n\n  // Put at end of history\n  state.history.push(current);\n  // Remove oldest if too much history\n  if (state.history.length > getConfiguration().historySize) {\n    state.history.shift();\n  }\n}\n\nexport function undo (element) {\n  const thresholdingData = getToolState(element, 'regions');\n  const state = thresholdingData.data[0];\n\n  if (state.history.length < 1) {\n    return;\n  }\n\n  const replacement = state.history.pop();\n\n  state.buffer = replacement;\n  external.cornerstone.updateImage(element);\n}\n\nexport function redo () {\n  // Not implemented\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lesionTools/history.js","export { default as external } from './externalModules.js';\nexport { getConfiguration, setConfiguration } from './configuration.js';\n\nexport { default as display } from './lesionTools/display.js';\nexport { default as threshold } from './lesionTools/threshold.js';\nexport { default as grow } from './lesionTools/grow.js';\nexport { default as draw } from './lesionTools/draw.js';\nexport { default as score } from './lesionTools/score.js';\nexport { undo, redo } from './lesionTools/history.js';\n\n\n\n// WEBPACK FOOTER //\n// ./index.js","import external from '../externalModules.js';\nimport { TYPED_ARRAY } from '../constants.js';\nimport { getConfiguration } from '../configuration.js';\n\nconst { displayTool, getToolState } = external.cornerstoneTools;\n\n/**\n * Draw regions on image\n */\nfunction onImageRendered ({ detail }) {\n  const configuration = getConfiguration();\n  const { canvasContext, element, enabledElement, image } = detail;\n  const { width, height } = image;\n\n  const stackToolData = getToolState(element, 'stack');\n  const regionsToolData = getToolState(element, 'regions');\n\n  // Ensure tool is enabled\n  if (!regionsToolData || !regionsToolData.data || !regionsToolData.data.length) {\n    return;\n  }\n\n  if (!regionsToolData.data[0].drawBuffer || width !== regionsToolData.data[0].drawBuffer.canvas.width) {\n    const canvas = document.createElement('canvas');\n    const context = canvas.getContext('2d');\n    const imageData = context.createImageData(width, height);\n\n    canvas.width = width;\n    canvas.height = height;\n\n    regionsToolData.data[0].drawBuffer = {\n      canvas,\n      imageData\n    };\n  }\n\n  // Extract tool data\n  const { currentImageIdIndex } = stackToolData.data[0];\n  const { drawBuffer, buffer } = regionsToolData.data[0];\n\n  const doubleBuffer = drawBuffer.canvas;\n  const imageData = drawBuffer.imageData;\n\n  const pixels = imageData.data;\n  const sliceSize = width * height;\n  const sliceOffset = currentImageIdIndex * sliceSize;\n  const view = new TYPED_ARRAY(buffer, sliceOffset, sliceSize);\n\n  for (let offset = 0; offset < view.length; offset += 1) {\n    // Each pixel is represented by four elements in the imageData array\n    const imageDataOffset = offset * 4;\n    const label = view[offset];\n\n    if (label) {\n      const color = configuration.regionColorsRGB[label - 1];\n\n      pixels[imageDataOffset + 0] = color[0];\n      pixels[imageDataOffset + 1] = color[1];\n      pixels[imageDataOffset + 2] = color[2];\n      pixels[imageDataOffset + 3] = configuration.drawAlpha * 255;\n    } else {\n      pixels[imageDataOffset + 3] = 0;\n    }\n  }\n\n  // Put image data back into offscreen canvas\n  doubleBuffer.getContext('2d').putImageData(imageData, 0, 0);\n  // Set transforms based on zoom/pan/etc\n  external.cornerstone.setToPixelCoordinateSystem(enabledElement, canvasContext);\n  // Finally, draw offscreen canvas onto context\n  canvasContext.drawImage(doubleBuffer, 0, 0);\n}\n\nconst lesionIndicator = displayTool(onImageRendered);\n\nexport default lesionIndicator;\n\n\n\n// WEBPACK FOOTER //\n// ./lesionTools/display.js","import external from '../externalModules.js';\nimport { TYPED_ARRAY, TOOL_TYPE } from '../constants.js';\nimport { getConfiguration } from '../configuration.js';\n\nconst { addToolState, getToolState } = external.cornerstoneTools;\n\n/**\n * Perform the thresholding on a stack\n */\nfunction performThresholding (imageIds) {\n  let width, height, view, buffer;\n\n  const configuration = getConfiguration();\n\n  // Thresholding promises\n  return Promise.all(imageIds.map((imageId, imageIdIndex) =>\n    external.cornerstone.loadImage(imageId).then((image) => {\n      if (!buffer) {\n        // Initialize variables on first loaded image\n        width = image.width;\n        height = image.height;\n\n        const length = width * height * imageIds.length;\n\n        buffer = new ArrayBuffer(length);\n        view = new TYPED_ARRAY(buffer);\n      }\n\n      const { intercept, slope } = image;\n      const pixelData = image.getPixelData();\n      const sliceSize = width * height;\n\n      for (let i = 0; i < sliceSize; i++) {\n        const value = pixelData[i];\n        // Calculate hu-value\n        const hu = (value * slope) + intercept;\n        // Check against threshold\n        const label = (hu >= configuration.calciumThresholdHu) ? 1 : 0;\n        // Calculate offset within view into ArrayBufer\n        const offset = imageIdIndex * sliceSize + i;\n\n        // Finally, assign label\n        view[offset] = label;\n      }\n    })\n  // When all promises resolve, return the buffer and its dimensions\n  )).then(() => ({\n    buffer,\n    width,\n    height\n  }));\n}\n\nfunction ensureToolData (element) {\n  let regionsData;\n\n  const regionsToolData = getToolState(element, TOOL_TYPE);\n\n  if (!regionsToolData || !regionsToolData.data || !regionsToolData.data.length) {\n    regionsData = {\n      enabled: 1,\n      buffer: null,\n      width: null,\n      height: null,\n      history: [],\n      drawBuffer: null\n    };\n    addToolState(element, TOOL_TYPE, regionsData);\n  } else {\n    regionsData = regionsToolData.data[0];\n  }\n\n  return regionsData;\n}\n\nfunction threshold (element) {\n  const stackToolData = getToolState(element, 'stack');\n\n  if (!stackToolData || !stackToolData.data || !stackToolData.data.length) {\n    return;\n  }\n\n  const stackData = stackToolData.data[0];\n  const regionsData = ensureToolData(element);\n\n  performThresholding(stackData.imageIds).then((regions) => {\n    // Add threshold data to tool state\n    regionsData.buffer = regions.buffer;\n    regionsData.width = regions.width;\n    regionsData.height = regions.height;\n\n    // Update the element to apply the viewport and tool changes\n    external.cornerstone.updateImage(element);\n  });\n}\n// Module/private exports\nexport default threshold;\n\n\n\n// WEBPACK FOOTER //\n// ./lesionTools/threshold.js","import external from '../externalModules.js';\nimport { createUndoStep } from './history.js';\nimport { getConfiguration } from '../configuration.js';\n\nconst {\n  getToolState,\n  simpleMouseButtonTool,\n  isMouseButtonEnabled,\n  getToolOptions\n} = external.cornerstoneTools;\n\nconst toolType = 'regionsGrow';\n\n// Get neighbour linear indices within slice bounds\nfunction linearNeighbours (width, height, highSlice, lowSlice, index) {\n  const sliceSize = width * height;\n  const neighbours = [\n    index - 1,\n    index + 1,\n    index - width,\n    index + width\n  ];\n\n  // Stay within bounds\n  const sliceIndex = Math.floor(index / sliceSize);\n\n  if (sliceIndex < highSlice) {\n    neighbours.push(index + sliceSize);\n  }\n  if (sliceIndex > lowSlice) {\n    neighbours.push(index - sliceSize);\n  }\n\n  return neighbours;\n}\n\nfunction regionGrowing (regions, point) {\n  const { growIterationsPerChunk, toolRegionValue, layersAbove, layersBelow } = getConfiguration();\n  const { width, height, buffer } = regions;\n  const [x, y, slice] = point;\n  const highSlice = slice + layersBelow;\n  const lowSlice = slice - layersAbove;\n\n  const view = new Uint8Array(buffer);\n\n  // Calculate linear indices and offsets\n  const sliceSize = width * height;\n  const sliceOffset = sliceSize * slice;\n  const clickIndex = (y * width) + x;\n  const linearIndex = sliceOffset + clickIndex;\n  const fromValue = view[linearIndex];\n\n  // Only continue if we clicked in thresholded area in different color\n  if (fromValue === 0 || fromValue === toolRegionValue) {\n    return Promise.resolve();\n  }\n\n  // Growing starts at clicked voxel\n  let activeVoxels = [linearIndex];\n\n  return new Promise((resolve) => {\n    function chunk () {\n      for(let i = 0; i < growIterationsPerChunk; i++) {\n        // While activeVoxels is not empty\n        if (activeVoxels.length === 0) {\n          return resolve();\n        }\n\n        // Set the active voxels to nextValue\n        activeVoxels.forEach((i) => {\n          view[i] = toolRegionValue;\n        });\n\n        // The new active voxels are neighbours of curent active voxels\n        const nextVoxels = activeVoxels.map(\n          (i) => linearNeighbours(width, height, highSlice, lowSlice, i)\n        ).reduce( // Flatten the array of arrays to array of indices\n          (acc, cur) => acc.concat(cur), []\n        ).filter( // Remove duplicates\n          (value, index, self) => self.indexOf(value) === index\n        ).filter( // Remove voxels that does not have the correct fromValue\n          (i) => view[i] === fromValue\n        );\n\n        activeVoxels = nextVoxels;\n      }\n      setTimeout(chunk, 0);\n    }\n\n    chunk();\n  });\n}\n\nfunction mouseDownCallback (e) {\n  const { currentPoints, element, which } = e.detail;\n  const options = getToolOptions(toolType, element);\n\n  if (isMouseButtonEnabled(which, options.mouseButtonMask)) {\n    const [stackData] = getToolState(element, 'stack').data;\n    const [regionsData] = getToolState(element, 'regions').data;\n    const { currentImageIdIndex } = stackData;\n    const { x, y } = currentPoints.image;\n    const point = [Math.round(x), Math.round(y), currentImageIdIndex];\n\n    createUndoStep(element);\n    regionGrowing(regionsData, point).then(() => {\n      external.cornerstone.updateImage(element);\n    });\n  }\n}\n\nexport default simpleMouseButtonTool(mouseDownCallback, toolType);\n\n\n\n// WEBPACK FOOTER //\n// ./lesionTools/grow.js","import external from '../externalModules.js';\nimport pointInsidePolygon from '../util/pointInsidePolygon.js';\nimport { getConfiguration } from '../configuration.js';\n\nimport { createUndoStep } from './history.js';\n\nconst { toolColors, getToolState, getToolOptions, setToolOptions, simpleMouseButtonTool, isMouseButtonEnabled } = external.cornerstoneTools;\n\nconst toolType = 'draw';\n\nfunction updateRegions (element) {\n  const { snap, toolRegionValue, layersAbove, layersBelow } = getConfiguration();\n\n  createUndoStep(element);\n\n  // Get tool data\n  const stackData = getToolState(element, 'stack');\n  const thresholdingData = getToolState(element, 'regions');\n  const options = getToolOptions(toolType, element);\n\n  // Extract tool data\n  const slice = stackData.data[0].currentImageIdIndex;\n  const numSlices = stackData.data[0].imageIds.length;\n  const regions = thresholdingData.data[0];\n\n  // Extract region data\n  const buffer = regions.buffer;\n  const width = regions.width;\n  const height = regions.height;\n\n  // Find operation bounds\n  const startSlice = Math.max(0, slice - layersAbove);\n  const endSlice = Math.min(numSlices, slice + layersBelow);\n\n  // Setup view into buffer\n  const sliceSize = width * height;\n  const sliceOffset = startSlice * sliceSize;\n  const view = new Uint8Array(buffer, sliceOffset);\n\n  // Mark points inside\n  for (let dslice = 0; dslice <= endSlice - startSlice; dslice += 1) {\n    for (let x = 0; x < width; x += 1) {\n      for (let y = 0; y < height; y += 1) {\n        const index = x + (y * width) + (dslice * sliceSize);\n        const prevValue = view[index];\n\n        let snapBool;\n\n        if (snap) {\n          snapBool = prevValue > 0;\n        } else {\n          snapBool = true;\n        }\n        const point = {\n          x,\n          y\n        };\n\n        if (snapBool && pointInsidePolygon(point, options.points)) {\n          view[index] = toolRegionValue;\n        }\n      }\n    }\n  }\n}\n\n// Draw regions on the canvas\nfunction imageRenderedCallback (e) {\n  const { canvasContext, enabledElement, element } = e.detail;\n\n  // Points\n  const options = getToolOptions(toolType, element);\n  const points = options.points;\n\n  if (points.length < 2) {\n    return;\n  }\n\n  // Set the canvas context to the image coordinate system\n  external.cornerstone.setToPixelCoordinateSystem(enabledElement, canvasContext);\n\n  canvasContext.fillStyle = toolColors.getFillColor();\n  canvasContext.strokeStyle = toolColors.getActiveColor();\n  canvasContext.beginPath();\n  canvasContext.moveTo(points[0].x, points[0].y);\n  points.slice(1).forEach(function (point) {\n    canvasContext.lineTo(point.x, point.y);\n  });\n  canvasContext.closePath();\n  canvasContext.stroke();\n  canvasContext.fill();\n}\n\nfunction dragCallback (e) {\n  const { currentPoints, element } = e.detail;\n  const options = getToolOptions(toolType, element);\n\n  options.points.push(currentPoints.image);\n  external.cornerstone.updateImage(element);\n\n  e.preventDefault();\n  e.stopPropagation();\n}\n\n// Disable drawing and tracking on mouse up also update regions\nfunction mouseUpCallback (e) {\n  const { element } = e.detail;\n\n  element.removeEventListener('cornerstonetoolsmousedrag', dragCallback);\n  element.removeEventListener('cornerstonetoolsmouseup', mouseUpCallback);\n  element.removeEventListener('cornerstonetoolsmouseclick', mouseUpCallback);\n  element.removeEventListener('cornerstoneimagerendered', imageRenderedCallback);\n\n  updateRegions(element);\n  external.cornerstone.updateImage(element);\n}\n\n// Start drawing and tracking on mouse up, also reset points array\nfunction mouseDownCallback (e) {\n  const { element, which } = e.detail;\n  const options = getToolOptions(toolType, element);\n\n  if (isMouseButtonEnabled(which, options.mouseButtonMask)) {\n    options.points = [];\n\n    setToolOptions(toolType, element, options);\n\n    element.addEventListener('cornerstonetoolsmousedrag', dragCallback);\n    element.addEventListener('cornerstonetoolsmouseup', mouseUpCallback);\n    element.addEventListener('cornerstonetoolsmouseclick', mouseUpCallback);\n    element.addEventListener('cornerstoneimagerendered', imageRenderedCallback);\n\n    e.preventDefault();\n    e.stopPropagation();\n  }\n}\n\nexport default simpleMouseButtonTool(mouseDownCallback, toolType);\n\n\n\n// WEBPACK FOOTER //\n// ./lesionTools/draw.js","// Determine if a point is inside a polygon\nexport default function pointInsidePolygon (point, polygon) {\n  const { x, y } = point;\n  const n = polygon.length;\n  let inside = false;\n\n  for (let i = 0, j = n - 1; i < n; j = i++) {\n    const { x: xi, y: yi } = polygon[i];\n    const { x: xj, y: yj } = polygon[j];\n\n    const intersect = ((yi > y) !== (yj > y)) &&\n      (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n\n    if (intersect) {\n      inside = !inside;\n    }\n  }\n\n  return inside;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./util/pointInsidePolygon.js","import external from '../externalModules.js';\nimport { getConfiguration } from '../configuration.js';\nimport { TYPED_ARRAY, TOOL_TYPE } from '../constants.js';\n\nconst { getToolState } = external.cornerstoneTools;\n\nfunction getDensityFactor (hu) {\n  if (hu < 130) {\n    return 0;\n  } else if (hu < 200) {\n    return 1;\n  } else if (hu < 300) {\n    return 2;\n  } else if (hu < 400) {\n    return 3;\n  }\n\n  return 4;\n}\n\n// Finds the value with the most occurrences in array\n// Should be O(n)\nfunction mode (array) {\n  if (array.length === 0) {\n    return null;\n  }\n  const modeMap = {};\n  let maxEl = array[0];\n  let maxCount = 1;\n\n  for (let i = 0; i < array.length; i++) {\n    const el = array[i];\n\n    if (modeMap[el] === null) {\n      modeMap[el] = 1;\n    } else {\n      modeMap[el]++;\n    }\n\n    if(modeMap[el] > maxCount) {\n      maxEl = el;\n      maxCount = modeMap[el];\n    }\n  }\n\n  return maxEl;\n}\n\nexport function computeVoxelSize (metaData) {\n  if (metaData.sliceThickness === 0 ||\n      metaData.pixelSpacing[0] === 0 ||\n      metaData.pixelSpacing[1] === 0) {\n    throw new Error('sliceThickness or pixelSpacing was 0');\n  }\n  const zLength = metaData.sliceThickness;\n  const xLength = metaData.pixelSpacing[0];\n  const yLength = metaData.pixelSpacing[1];\n\n\n  return zLength * xLength * yLength; // In mm\n}\n\nexport function computeScore (metaData, voxels) {\n  // Division by 3 because Agatson score assumes a slice thickness of 3 mm\n  const voxelSizeScaled = computeVoxelSize(metaData) / 3;\n  const densityFactor = getDensityFactor(metaData.maxHU);\n  const volume = voxels.length * voxelSizeScaled;\n\n  const { KVPToMultiplier } = getConfiguration();\n  const KVPMultiplier = KVPToMultiplier[metaData.KVP];\n  const cascore = volume * densityFactor * KVPMultiplier;\n\n /*\n  console.log(`modeOverlapFactor: ${metaData.modeOverlapFactor}`);\n  console.log(`voxels.length: ${voxels.length}`);\n  console.log(`voxelSizeScaled: ${voxelSizeScaled}`);\n  console.log(`Volume: ${volume}`);\n  console.log(`Max HU: ${metaData.maxHU}`);\n  console.log(`densityFactor: ${densityFactor}`);\n  console.log(`KVPMultiplier: ${KVPMultiplier}`);\n  console.log(`CAscore: ${cascore}`); */\n\n  // If modeOverlapFactor factor is undefined it is because there is only one slice in the series.\n  // In this case obviously modeOverlapFactor is meaningless and should not be multiplied with cascore.\n  if (metaData.modeOverlapFactor) {\n    return cascore * metaData.modeOverlapFactor;\n  }\n\n  return cascore;\n\n}\n\n/*\n* Computes the distance between two slices based on the DICOM Image Plane Module\n* @param imagePositions {Array[2][3]} - DICOM tag (0020, 0032) of two slices\n* @param imageOrientation {Array[2][3]} - DICOM tag (0020, 0037) of first slice\n*/\nexport function computeIOPProjectedDistance (imagePositions, imageOrientation) {\n  const imagePosition1Vector = new external.cornerstoneMath.Vector3();\n\n  imagePosition1Vector.fromArray(imagePositions[0]);\n\n  const imagePosition2Vector = new external.cornerstoneMath.Vector3();\n\n  imagePosition2Vector.fromArray(imagePositions[1]);\n\n  const imageOrientationRowVector = new external.cornerstoneMath.Vector3();\n\n  imageOrientationRowVector.fromArray(imageOrientation[0]);\n\n  const imageOrientationColumnVector = new external.cornerstoneMath.Vector3();\n\n  imageOrientationColumnVector.fromArray(imageOrientation[1]);\n\n  // Compute unit normal of Image Orientation crossVectors\n  const orientationNormal = new external.cornerstoneMath.Vector3();\n\n  orientationNormal.crossVectors(imageOrientationRowVector, imageOrientationColumnVector);\n  // Project both position vectors on normal\n  const projection1 = imagePosition1Vector.projectOnVector(orientationNormal);\n  const projection2 = imagePosition2Vector.projectOnVector(orientationNormal);\n\n  // Compute distance of projected vectors\n  return projection1.distanceTo(projection2);\n}\n\nexport function computeOverlapFactor (distance, sliceThickness) {\n  if (distance <= 0) {\n    throw new Error('Distance must be > 0');\n  }\n\n  if (distance >= sliceThickness) {\n    return 1;\n  }\n\n  const overlap = sliceThickness - distance;\n\n  return (sliceThickness - overlap) / (sliceThickness);\n}\n\nfunction bfs (x, y, view, visitedVoxels, label, image) {\n  const { intercept, slope, width } = image;\n  const pixelData = image.getPixelData();\n  const lesionVoxels = [];\n  const stack = [[x, y]];\n\n  while (stack.length > 0) {\n    const [x, y] = stack.shift();\n\n    // If visited is 0, the element has not been visisted before\n    if (visitedVoxels[x][y] === 0 && view[y * width + x] === label) {\n      stack.push([x - 1, y]);\n      stack.push([x + 1, y]);\n      stack.push([x, y - 1]);\n      stack.push([x, y + 1]);\n\n      const value = pixelData[x + y * width];\n      const hu = (value * slope) + intercept;\n\n      if (hu >= 130) {\n        lesionVoxels.push(hu);\n      }\n      visitedVoxels[x][y] = 1;\n    }\n\n  }\n\n  return lesionVoxels;\n}\n\n/**\n * Calculate CaScore per label per slice per lesion\n *\n */\nexport function score (element) {\n  const { regionColorsRGB } = getConfiguration();\n\n  const regionsToolData = getToolState(element, TOOL_TYPE);\n  const stackToolData = getToolState(element, 'stack');\n  const { buffer } = regionsToolData.data[0];\n  const { imageIds } = stackToolData.data[0];\n\n  // Extract and group region-voxels\n  const voxelsEachRegion = regionColorsRGB.slice(1).map(() => imageIds.map(() => []));\n  const maxHUEachRegion = regionColorsRGB.slice(1).map(() => imageIds.map(() => []));\n\n  let overlapFactor;\n  let prevImagePosition;\n  const overlapFactors = [];\n\n  const metaData = {};\n\n  return Promise.all(imageIds.map((imageId, imageIndex) =>\n    external.cornerstone.loadImage(imageId).then((image) => {\n      const dataSet = image.data;\n\n      metaData.sliceThickness = dataSet.floatString('x00180050');\n      metaData.pixelSpacing = dataSet.string('x00280030').split('\\\\').map(parseFloat);\n      metaData.KVP = dataSet.floatString('x00180060');\n      metaData.rescaleSlope = dataSet.floatString('x00281053');\n      metaData.rescaleIntercept = dataSet.floatString('x00281052');\n      metaData.rescaleType = dataSet.string('x00281054');\n\n      const imagePositionPatient = dataSet.string('x00200032').split('\\\\').map(parseFloat);\n      const imageOrientationTmp = dataSet.string('x00200037').split('\\\\').map(parseFloat);\n      const imageOrientation = [\n        imageOrientationTmp.slice(0, 3),\n        imageOrientationTmp.slice(3)\n      ];\n\n      /* What is this?\n       if (metaData.rescaleType !== 'HU') {\n         console.warn(`Modality LUT does not convert to Hounsfield units but to ${metaData.rescaleType}. Agatston score is not defined for this unit type.`);\n\n         return;\n      }\n       */\n\n      if (prevImagePosition) {\n        const distance = computeIOPProjectedDistance([prevImagePosition, imagePositionPatient], imageOrientation);\n\n        overlapFactor = computeOverlapFactor(distance, metaData.sliceThickness);\n\n        // Find overlapfactor with the highest occurance\n        overlapFactors.push(overlapFactor);\n        metaData.modeOverlapFactor = mode(overlapFactors);\n\n        // Save imagePositionPatient for next overlapFactor computation\n        prevImagePosition = imagePositionPatient;\n      } else {\n        prevImagePosition = imagePositionPatient;\n      }\n\n      // Overlap has been calculated, now we investigate voxels\n\n      const { height, width } = image;\n      const sliceSize = width * height;\n      const offset = imageIndex * sliceSize;\n\n      const view = new TYPED_ARRAY(buffer, offset, sliceSize);\n\n      // Initialze with 0's\n      const visitedVoxels = Array(width).fill().map(() => Array(height).fill(0));\n\n      for (let x = 0; x < width; x += 1) {\n        for (let y = 0; y < height; y += 1) {\n          // Extract label from view into ArrayBuffer\n          const label = view[y * width + x];\n\n          if (label > 1) {\n            const lesionVoxels = bfs(x, y, view, visitedVoxels, label, image);\n\n            if (lesionVoxels.length) {\n              const maxHU = Math.max(...lesionVoxels);\n\n              voxelsEachRegion[label - 2][imageIndex].push(lesionVoxels);\n              maxHUEachRegion[label - 2][imageIndex].push(maxHU);\n            }\n          }\n        }\n      }\n    })\n  // When all images have been processed\n  )).then(() => voxelsEachRegion.map((slicesInLabel, labelIdx) => {\n    const cascore = [];\n\n    slicesInLabel.forEach((lesions, sliceIdx) => {\n      lesions.forEach((voxels, lesionIdx) => {\n        metaData.maxHU = maxHUEachRegion[labelIdx][sliceIdx][lesionIdx];\n\n        const cascoreCurrent = voxels.length > 0 ? computeScore(metaData, voxels) : 0;\n\n        cascore.push(cascoreCurrent);\n      });\n    });\n    const sum = cascore.reduce((acc, val) => acc + val, 0);\n\n    return sum;\n  }));\n}\n\nexport default score;\n\n\n\n// WEBPACK FOOTER //\n// ./lesionTools/score.js"],"sourceRoot":""}