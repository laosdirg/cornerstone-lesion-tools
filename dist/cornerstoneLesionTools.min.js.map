{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///cornerstoneLesionTools.min.js","webpack:///webpack/bootstrap f40f514588cf2a1c19d6","webpack:///./externalModules.js","webpack:///./lesionTools/threshold.js","webpack:///./lesionTools/constants.js","webpack:///./lesionTools/history.js","webpack:///./index.js","webpack:///./lesionTools/display.js","webpack:///./lesionTools/grow.js","webpack:///./lesionTools/draw.js","webpack:///./util/pointInsidePolygon.js","webpack:///./lesionTools/score.js"],"names":["root","factory","exports","module","define","amd","self","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","value","cornerstone","window","cornerstoneTools","default","cst","performThresholding","imageIds","width","height","view","buffer","Promise","all","map","imageId","imageIdIndex","_externalModules2","loadImage","then","image","length","ArrayBuffer","_constants","TYPED_ARRAY","intercept","slope","pixelData","getPixelData","sliceSize","hu","label","configuration","calciumThresholdHu","ensureToolData","element","regionsData","regionsToolData","getToolState","TOOL_TYPE","data","enabled","history","drawBuffer","addToolState","threshold","stackToolData","console","log","stackData","regions","updateImage","getConfiguration","setConfiguration","config","_externalModules","obj","_external$cornerstone","historySize","layersAbove","layersBelow","historyPosition","toolRegionValue","drawAlpha","regionColorsRGB","KVPToMultiplier","150","140","130","120","110","100","90","80","70","growIterationsPerChunk","calciumThresholdHuParsed","parseInt","Uint8Array","createUndoStep","thresholdingData","state","current","slice","push","shift","undo","replacement","pop","redo","_interopRequireDefault","_display","_threshold","_grow","_draw","_score","_history","onImageRendered","_ref","detail","canvasContext","enabledElement","canvas","document","createElement","context","getContext","imageData","createImageData","currentImageIdIndex","_regionsToolData$data","doubleBuffer","pixels","sliceOffset","offset","imageDataOffset","color","putImageData","setToPixelCoordinateSystem","drawImage","displayTool","lesionIndicator","linearNeighbours","highSlice","lowSlice","index","neighbours","sliceIndex","Math","floor","regionGrowing","point","_threshold$getConfigu","_threshold2","_point","_slicedToArray","x","y","clickIndex","linearIndex","fromValue","resolve","activeVoxels","chunk","forEach","nextVoxels","reduce","acc","cur","concat","filter","indexOf","setTimeout","mouseDownCallback","e","_e$detail","currentPoints","which","options","getToolOptions","toolType","isMouseButtonEnabled","mouseButtonMask","_getToolState$data","_getToolState$data2","_currentPoints$image","round","sliceIterator","arr","_arr","_n","_d","_e","undefined","_s","_i","Symbol","iterator","next","done","err","Array","isArray","TypeError","simpleMouseButtonTool","grow","updateRegions","numSlices","startSlice","max","endSlice","min","dslice","prevValue","snapBool","snap","_pointInsidePolygon2","points","imageRenderedCallback","_draw$getConfiguratio","draw","fillStyle","strokeStyle","beginPath","moveTo","lineTo","closePath","stroke","fill","dragCallback","_e$detail2","preventDefault","stopPropagation","mouseUpCallback","removeEventListener","_e$detail3","setToolOptions","addEventListener","_pointInsidePolygon","pointInsidePolygon","vs","inside","j","_vs$i","xi","yi","_vs$j","xj","yj","_toConsumableArray","arr2","from","getDensityFactor","mode","array","modeMap","maxEl","maxCount","el","computeVoxelSize","metaData","sliceThickness","pixelSpacing","Error","computeScore","voxels","voxelSizeScaled","densityFactor","maxHU","volume","_getConfiguration","KVPMultiplier","KVP","cascore","modeOverlapFactor","computeIOPProjectedDistance","imagePositions","imageOrientation","imagePosition1Vector","cornerstoneMath","Vector3","fromArray","imagePosition2Vector","imageOrientationRowVector","imageOrientationColumnVector","orientationNormal","crossVectors","projection1","projectOnVector","projection2","distanceTo","computeOverlapFactor","distance","bfs","visitedVoxels","lesionVoxels","stack","_stack$shift","_stack$shift2","score","getLastElement","_getConfiguration2","voxelsEachRegion","maxHUEachRegion","overlapFactor","prevImagePosition","overlapFactors","imageIndex","dataSet","floatString","string","split","parseFloat","rescaleSlope","rescaleIntercept","rescaleType","imagePositionPatient","imageOrientationTmp","apply","slicesInLabel","labelIdx","lesions","sliceIdx","lesionIdx","cascoreCurrent","val"],"mappings":"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","file":"cornerstoneLesionTools.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"cornerstoneLesionTools\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"cornerstoneLesionTools\"] = factory();\n\telse\n\t\troot[\"cornerstoneLesionTools\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","/*! cornerstone-lesion-tools - 0.1.0 - 2018-03-12 | (c) 2017 Chris Hafey | undefined */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"cornerstoneLesionTools\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"cornerstoneLesionTools\"] = factory();\n\telse\n\t\troot[\"cornerstoneLesionTools\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 4);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar cornerstone = window.cornerstone;\nvar cornerstoneTools = window.cornerstoneTools;\n\nexports.default = {\n  set cornerstone(cst) {\n    cornerstone = cst;\n  },\n  get cornerstone() {\n    return cornerstone;\n  },\n  set cornerstoneTools(cst) {\n    cornerstoneTools = cst;\n  },\n  get cornerstoneTools() {\n    return cornerstoneTools;\n  }\n};\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _externalModules = __webpack_require__(0);\n\nvar _externalModules2 = _interopRequireDefault(_externalModules);\n\nvar _constants = __webpack_require__(2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _external$cornerstone = _externalModules2.default.cornerstoneTools,\n    addToolState = _external$cornerstone.addToolState,\n    getToolState = _external$cornerstone.getToolState;\n\n\nvar configuration = {\n  historySize: 4,\n  layersAbove: 1,\n  layersBelow: 1,\n  historyPosition: 0,\n  toolRegionValue: 2,\n  calciumThresholdHu: '-', // Placeholder until it gets set ('-' shows up nicely in text input)\n  drawAlpha: 1,\n  regionColorsRGB: [[255, 0, 255], [246, 193, 91], [237, 148, 69], [230, 103, 49], [184, 74, 41], [106, 58, 45]],\n  KVPToMultiplier: {\n    150: 1.06,\n    140: 1.04,\n    130: 1.02,\n    120: 1,\n    110: 0.98,\n    100: 0.96,\n    90: 0.93,\n    80: 0.89,\n    70: 0.85\n  },\n  growIterationsPerChunk: 2\n};\n\nconfiguration.calciumThresholdHuParsed = parseInt(configuration.calciumThresholdHu, 10);\n\n/**\n * Perform the thresholding on a stack\n */\nfunction performThresholding(imageIds) {\n  var width = void 0,\n      height = void 0,\n      view = void 0,\n      buffer = void 0;\n\n  // Thresholding promises\n  return Promise.all(imageIds.map(function (imageId, imageIdIndex) {\n    return _externalModules2.default.cornerstone.loadImage(imageId).then(function (image) {\n      if (!buffer) {\n        // Initialize variables on first loaded image\n        width = image.width;\n        height = image.height;\n\n        var length = width * height * imageIds.length;\n\n        buffer = new ArrayBuffer(length);\n        view = new _constants.TYPED_ARRAY(buffer);\n      }\n\n      var intercept = image.intercept,\n          slope = image.slope;\n\n      var pixelData = image.getPixelData();\n      var sliceSize = width * height;\n\n      for (var i = 0; i < sliceSize; i++) {\n        var value = pixelData[i];\n        // Calculate hu-value\n        var hu = value * slope + intercept;\n        // Check against threshold\n        var label = hu >= configuration.calciumThresholdHu ? 1 : 0;\n        // Calculate offset within view into ArrayBufer\n        var offset = imageIdIndex * sliceSize + i;\n\n        // Finally, assign label\n        view[offset] = label;\n      }\n    });\n  }\n  // When all promises resolve, return the buffer and its dimensions\n  )).then(function () {\n    return {\n      buffer: buffer,\n      width: width,\n      height: height\n    };\n  });\n}\n\nfunction ensureToolData(element) {\n  var regionsData = void 0;\n\n  var regionsToolData = getToolState(element, _constants.TOOL_TYPE);\n\n  if (!regionsToolData || !regionsToolData.data || !regionsToolData.data.length) {\n    regionsData = {\n      enabled: 1,\n      buffer: null,\n      width: null,\n      height: null,\n      history: [],\n      drawBuffer: null\n    };\n    addToolState(element, _constants.TOOL_TYPE, regionsData);\n  } else {\n    regionsData = regionsToolData.data[0];\n  }\n\n  return regionsData;\n}\n\nfunction threshold(element) {\n  var stackToolData = getToolState(element, 'stack');\n  console.log(\"got stack\", stackToolData);\n  if (!stackToolData || !stackToolData.data || !stackToolData.data.length) {\n    return;\n  }\n\n  var stackData = stackToolData.data[0];\n  var regionsData = ensureToolData(element);\n\n  console.log(\"ABOUT TO PERFORM\");\n\n  performThresholding(stackData.imageIds).then(function (regions) {\n    // Add threshold data to tool state\n    regionsData.buffer = regions.buffer;\n    regionsData.width = regions.width;\n    regionsData.height = regions.height;\n\n    // Update the element to apply the viewport and tool changes\n    _externalModules2.default.cornerstone.updateImage(element);\n  });\n}\n\nfunction getConfiguration() {\n  return configuration;\n}\n\nfunction setConfiguration(config) {\n  configuration = config;\n}\n\n// Module/private exports\nexports.default = {\n  threshold: threshold,\n  getConfiguration: getConfiguration,\n  setConfiguration: setConfiguration\n};\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar TYPED_ARRAY = exports.TYPED_ARRAY = Uint8Array;\nvar TOOL_TYPE = exports.TOOL_TYPE = 'regions';\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createUndoStep = createUndoStep;\nexports.undo = undo;\nexports.redo = redo;\n\nvar _externalModules = __webpack_require__(0);\n\nvar _externalModules2 = _interopRequireDefault(_externalModules);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar getToolState = _externalModules2.default.cornerstoneTools.getToolState;\n\n\nvar configuration = {};\n\n/**\n * Store current state to history\n */\nfunction createUndoStep(element) {\n  var thresholdingData = getToolState(element, 'regions');\n\n  var state = thresholdingData.data[0];\n  // Make a copy using .slice()\n  var current = state.buffer.slice();\n\n  // Put at end of history\n  state.history.push(current);\n  // Remove oldest if too much history\n  if (state.history.length > configuration.historySize) {\n    state.history.shift();\n  }\n}\n\nfunction undo(element) {\n  var thresholdingData = getToolState(element, 'regions');\n  var state = thresholdingData.data[0];\n\n  if (state.history.length < 1) {\n    return;\n  }\n\n  var replacement = state.history.pop();\n\n  state.buffer = replacement;\n  _externalModules2.default.cornerstone.updateImage(element);\n}\n\nfunction redo() {\n  // Not implemented\n}\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _externalModules = __webpack_require__(0);\n\nObject.defineProperty(exports, 'external', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_externalModules).default;\n  }\n});\n\nvar _display = __webpack_require__(5);\n\nObject.defineProperty(exports, 'display', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_display).default;\n  }\n});\n\nvar _threshold = __webpack_require__(1);\n\nObject.defineProperty(exports, 'threshold', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_threshold).default;\n  }\n});\n\nvar _grow = __webpack_require__(6);\n\nObject.defineProperty(exports, 'grow', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_grow).default;\n  }\n});\n\nvar _draw = __webpack_require__(7);\n\nObject.defineProperty(exports, 'draw', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_draw).default;\n  }\n});\n\nvar _score = __webpack_require__(9);\n\nObject.defineProperty(exports, 'score', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_score).default;\n  }\n});\n\nvar _history = __webpack_require__(3);\n\nObject.defineProperty(exports, 'undo', {\n  enumerable: true,\n  get: function get() {\n    return _history.undo;\n  }\n});\nObject.defineProperty(exports, 'redo', {\n  enumerable: true,\n  get: function get() {\n    return _history.redo;\n  }\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _externalModules = __webpack_require__(0);\n\nvar _externalModules2 = _interopRequireDefault(_externalModules);\n\nvar _constants = __webpack_require__(2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _external$cornerstone = _externalModules2.default.cornerstoneTools,\n    displayTool = _external$cornerstone.displayTool,\n    getToolState = _external$cornerstone.getToolState;\n\n\nvar configuration = {\n  drawAlpha: 1,\n  regionColorsRGB: [[255, 0, 255], [246, 193, 91], [237, 148, 69], [230, 103, 49], [184, 74, 41], [106, 58, 45]]\n};\n\n/**\n * Draw regions on image\n */\nfunction onImageRendered(_ref) {\n  var detail = _ref.detail;\n  var canvasContext = detail.canvasContext,\n      element = detail.element,\n      enabledElement = detail.enabledElement,\n      image = detail.image;\n  var width = image.width,\n      height = image.height;\n\n\n  var stackToolData = getToolState(element, 'stack');\n  var regionsToolData = getToolState(element, 'regions');\n\n  // Ensure tool is enabled\n  if (!regionsToolData || !regionsToolData.data || !regionsToolData.data.length) {\n    return;\n  }\n\n  if (!regionsToolData.data[0].drawBuffer || width !== regionsToolData.data[0].drawBuffer.canvas.width) {\n    var canvas = document.createElement('canvas');\n    var context = canvas.getContext('2d');\n    var _imageData = context.createImageData(width, height);\n\n    canvas.width = width;\n    canvas.height = height;\n\n    regionsToolData.data[0].drawBuffer = {\n      canvas: canvas,\n      imageData: _imageData\n    };\n  }\n\n  // Extract tool data\n  var currentImageIdIndex = stackToolData.data[0].currentImageIdIndex;\n  var _regionsToolData$data = regionsToolData.data[0],\n      drawBuffer = _regionsToolData$data.drawBuffer,\n      buffer = _regionsToolData$data.buffer;\n\n\n  var doubleBuffer = drawBuffer.canvas;\n  var imageData = drawBuffer.imageData;\n\n  var pixels = imageData.data;\n  var sliceSize = width * height;\n  var sliceOffset = currentImageIdIndex * sliceSize;\n  var view = new _constants.TYPED_ARRAY(buffer, sliceOffset, sliceSize);\n\n  for (var offset = 0; offset < view.length; offset += 1) {\n    // Each pixel is represented by four elements in the imageData array\n    var imageDataOffset = offset * 4;\n    var label = view[offset];\n\n    if (label) {\n      var color = configuration.regionColorsRGB[label - 1];\n\n      pixels[imageDataOffset + 0] = color[0];\n      pixels[imageDataOffset + 1] = color[1];\n      pixels[imageDataOffset + 2] = color[2];\n      pixels[imageDataOffset + 3] = configuration.drawAlpha * 255;\n    } else {\n      pixels[imageDataOffset + 3] = 0;\n    }\n  }\n\n  // Put image data back into offscreen canvas\n  doubleBuffer.getContext('2d').putImageData(imageData, 0, 0);\n  // Set transforms based on zoom/pan/etc\n  _externalModules2.default.cornerstone.setToPixelCoordinateSystem(enabledElement, canvasContext);\n  // Finally, draw offscreen canvas onto context\n  canvasContext.drawImage(doubleBuffer, 0, 0);\n}\n\nvar lesionIndicator = displayTool(onImageRendered);\n\nlesionIndicator.setConfiguration(configuration);\n\nexports.default = lesionIndicator;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _externalModules = __webpack_require__(0);\n\nvar _externalModules2 = _interopRequireDefault(_externalModules);\n\nvar _history = __webpack_require__(3);\n\nvar _threshold = __webpack_require__(1);\n\nvar _threshold2 = _interopRequireDefault(_threshold);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _external$cornerstone = _externalModules2.default.cornerstoneTools,\n    getToolState = _external$cornerstone.getToolState,\n    simpleMouseButtonTool = _external$cornerstone.simpleMouseButtonTool,\n    isMouseButtonEnabled = _external$cornerstone.isMouseButtonEnabled,\n    getToolOptions = _external$cornerstone.getToolOptions;\n\n\nvar toolType = 'regionsGrow';\n\n// Get neighbour linear indices within slice bounds\nfunction linearNeighbours(width, height, highSlice, lowSlice, index) {\n  var sliceSize = width * height;\n  var neighbours = [index - 1, index + 1, index - width, index + width];\n\n  // Stay within bounds\n  var sliceIndex = Math.floor(index / sliceSize);\n\n  if (sliceIndex < highSlice) {\n    neighbours.push(index + sliceSize);\n  }\n  if (sliceIndex > lowSlice) {\n    neighbours.push(index - sliceSize);\n  }\n\n  return neighbours;\n}\n\nfunction regionGrowing(regions, point) {\n  var _threshold$getConfigu = _threshold2.default.getConfiguration(),\n      growIterationsPerChunk = _threshold$getConfigu.growIterationsPerChunk,\n      toolRegionValue = _threshold$getConfigu.toolRegionValue,\n      layersAbove = _threshold$getConfigu.layersAbove,\n      layersBelow = _threshold$getConfigu.layersBelow;\n\n  var width = regions.width,\n      height = regions.height,\n      buffer = regions.buffer;\n\n  var _point = _slicedToArray(point, 3),\n      x = _point[0],\n      y = _point[1],\n      slice = _point[2];\n\n  var highSlice = slice + layersBelow;\n  var lowSlice = slice - layersAbove;\n\n  var view = new Uint8Array(buffer);\n\n  // Calculate linear indices and offsets\n  var sliceSize = width * height;\n  var sliceOffset = sliceSize * slice;\n  var clickIndex = y * width + x;\n  var linearIndex = sliceOffset + clickIndex;\n  var fromValue = view[linearIndex];\n\n  // Only continue if we clicked in thresholded area in different color\n  if (fromValue === 0 || fromValue === toolRegionValue) {\n    return Promise.resolve();\n  }\n\n  // Growing starts at clicked voxel\n  var activeVoxels = [linearIndex];\n\n  return new Promise(function (resolve) {\n    function chunk() {\n      for (var i = 0; i < growIterationsPerChunk; i++) {\n        // While activeVoxels is not empty\n        if (activeVoxels.length === 0) {\n          return resolve();\n        }\n\n        // Set the active voxels to nextValue\n        activeVoxels.forEach(function (i) {\n          view[i] = toolRegionValue;\n        });\n\n        // The new active voxels are neighbours of curent active voxels\n        var nextVoxels = activeVoxels.map(function (i) {\n          return linearNeighbours(width, height, highSlice, lowSlice, i);\n        }).reduce( // Flatten the array of arrays to array of indices\n        function (acc, cur) {\n          return acc.concat(cur);\n        }, []).filter( // Remove duplicates\n        function (value, index, self) {\n          return self.indexOf(value) === index;\n        }).filter( // Remove voxels that does not have the correct fromValue\n        function (i) {\n          return view[i] === fromValue;\n        });\n\n        activeVoxels = nextVoxels;\n      }\n      setTimeout(chunk, 0);\n    }\n\n    chunk();\n  });\n}\n\nfunction mouseDownCallback(e) {\n  var _e$detail = e.detail,\n      currentPoints = _e$detail.currentPoints,\n      element = _e$detail.element,\n      which = _e$detail.which;\n\n  var options = getToolOptions(toolType, element);\n\n  if (isMouseButtonEnabled(which, options.mouseButtonMask)) {\n    var _getToolState$data = _slicedToArray(getToolState(element, 'stack').data, 1),\n        stackData = _getToolState$data[0];\n\n    var _getToolState$data2 = _slicedToArray(getToolState(element, 'regions').data, 1),\n        regionsData = _getToolState$data2[0];\n\n    var currentImageIdIndex = stackData.currentImageIdIndex;\n    var _currentPoints$image = currentPoints.image,\n        x = _currentPoints$image.x,\n        y = _currentPoints$image.y;\n\n    var point = [Math.round(x), Math.round(y), currentImageIdIndex];\n\n    (0, _history.createUndoStep)(element);\n    regionGrowing(regionsData, point).then(function () {\n      _externalModules2.default.cornerstone.updateImage(element);\n    });\n  }\n}\n\nvar grow = simpleMouseButtonTool(mouseDownCallback, toolType);\n\nexports.default = grow;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _externalModules = __webpack_require__(0);\n\nvar _externalModules2 = _interopRequireDefault(_externalModules);\n\nvar _history = __webpack_require__(3);\n\nvar _pointInsidePolygon = __webpack_require__(8);\n\nvar _pointInsidePolygon2 = _interopRequireDefault(_pointInsidePolygon);\n\nvar _threshold = __webpack_require__(1);\n\nvar _threshold2 = _interopRequireDefault(_threshold);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _external$cornerstone = _externalModules2.default.cornerstoneTools,\n    getToolState = _external$cornerstone.getToolState,\n    getToolOptions = _external$cornerstone.getToolOptions,\n    setToolOptions = _external$cornerstone.setToolOptions,\n    simpleMouseButtonTool = _external$cornerstone.simpleMouseButtonTool,\n    isMouseButtonEnabled = _external$cornerstone.isMouseButtonEnabled;\n\n\nvar toolType = 'draw';\n\nvar configuration = {\n  snap: false, // Snap to thresholded region or not\n  fillStyle: 'rgba(255,255,255,.2)',\n  strokeStyle: 'white'\n};\n\nfunction updateRegions(element) {\n  var _threshold$getConfigu = _threshold2.default.getConfiguration(),\n      toolRegionValue = _threshold$getConfigu.toolRegionValue,\n      layersAbove = _threshold$getConfigu.layersAbove,\n      layersBelow = _threshold$getConfigu.layersBelow;\n\n  (0, _history.createUndoStep)(element);\n\n  // Get tool data\n  var stackData = getToolState(element, 'stack');\n  var thresholdingData = getToolState(element, 'regions');\n  var options = getToolOptions(toolType, element);\n\n  // Extract tool data\n  var slice = stackData.data[0].currentImageIdIndex;\n  var numSlices = stackData.data[0].imageIds.length;\n  var regions = thresholdingData.data[0];\n\n  // Extract region data\n  var buffer = regions.buffer;\n  var width = regions.width;\n  var height = regions.height;\n\n  // Find operation bounds\n  var startSlice = Math.max(0, slice - layersAbove);\n  var endSlice = Math.min(numSlices, slice + layersBelow);\n\n  // Setup view into buffer\n  var sliceSize = width * height;\n  var sliceOffset = startSlice * sliceSize;\n  var view = new Uint8Array(buffer, sliceOffset);\n\n  // Mark points inside\n  console.log(numSlices);\n  for (var dslice = 0; dslice <= endSlice - startSlice; dslice += 1) {\n    for (var x = 0; x < width; x += 1) {\n      for (var y = 0; y < height; y += 1) {\n        var index = x + y * width + dslice * sliceSize;\n        var prevValue = view[index];\n\n        var snapBool = void 0;\n\n        if (configuration.snap) {\n          snapBool = prevValue > 0;\n        } else {\n          snapBool = true;\n        }\n        if (snapBool && (0, _pointInsidePolygon2.default)({ x: x, y: y }, options.points)) {\n          view[index] = toolRegionValue;\n        }\n      }\n    }\n  }\n}\n\n// Draw regions on the canvas\nfunction imageRenderedCallback(e) {\n  var _e$detail = e.detail,\n      canvasContext = _e$detail.canvasContext,\n      enabledElement = _e$detail.enabledElement,\n      element = _e$detail.element;\n\n  var _draw$getConfiguratio = draw.getConfiguration(),\n      fillStyle = _draw$getConfiguratio.fillStyle,\n      strokeStyle = _draw$getConfiguratio.strokeStyle;\n\n  // Points\n\n\n  var options = getToolOptions(toolType, element);\n  var points = options.points;\n\n  if (points.length < 2) {\n    return;\n  }\n\n  // Set the canvas context to the image coordinate system\n  _externalModules2.default.cornerstone.setToPixelCoordinateSystem(enabledElement, canvasContext);\n\n  canvasContext.fillStyle = fillStyle;\n  canvasContext.strokeStyle = strokeStyle;\n  canvasContext.beginPath();\n  canvasContext.moveTo(points[0].x, points[0].y);\n  points.slice(1).forEach(function (point) {\n    canvasContext.lineTo(point.x, point.y);\n  });\n  canvasContext.closePath();\n  canvasContext.stroke();\n  canvasContext.fill();\n}\n\nfunction dragCallback(e) {\n  var _e$detail2 = e.detail,\n      currentPoints = _e$detail2.currentPoints,\n      element = _e$detail2.element;\n\n  var options = getToolOptions(toolType, element);\n\n  options.points.push(currentPoints.image);\n  _externalModules2.default.cornerstone.updateImage(element);\n\n  e.preventDefault();\n  e.stopPropagation();\n}\n\n// Disable drawing and tracking on mouse up also update regions\nfunction mouseUpCallback(e) {\n  var element = e.detail.element;\n\n\n  element.removeEventListener('cornerstonetoolsmousedrag', dragCallback);\n  element.removeEventListener('cornerstonetoolsmouseup', mouseUpCallback);\n  element.removeEventListener('cornerstonetoolsmouseclick', mouseUpCallback);\n  element.removeEventListener('cornerstoneimagerendered', imageRenderedCallback);\n\n  updateRegions(element);\n  _externalModules2.default.cornerstone.updateImage(element);\n}\n\n// Start drawing and tracking on mouse up, also reset points array\nfunction mouseDownCallback(e) {\n  var _e$detail3 = e.detail,\n      element = _e$detail3.element,\n      which = _e$detail3.which;\n\n  var options = getToolOptions(toolType, element);\n\n  if (isMouseButtonEnabled(which, options.mouseButtonMask)) {\n    options.points = [];\n\n    setToolOptions(toolType, element, options);\n\n    element.addEventListener('cornerstonetoolsmousedrag', dragCallback);\n    element.addEventListener('cornerstonetoolsmouseup', mouseUpCallback);\n    element.addEventListener('cornerstonetoolsmouseclick', mouseUpCallback);\n    element.addEventListener('cornerstoneimagerendered', imageRenderedCallback);\n\n    e.preventDefault();\n    e.stopPropagation();\n  }\n}\n\nvar draw = simpleMouseButtonTool(mouseDownCallback, toolType);\n\ndraw.getConfiguration = function () {\n  return configuration;\n};\ndraw.setConfiguration = function (config) {\n  configuration = config;\n};\n\nexports.default = draw;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nexports.default = pointInsidePolygon;\n// Determine if a point is inside a polygon\nfunction pointInsidePolygon(point, points) {\n  var vs = points.map(function (_ref) {\n    var x = _ref.x,\n        y = _ref.y;\n    return [x, y];\n  });\n  var x = point.x,\n      y = point.y;\n\n  var inside = false;\n\n  for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {\n    var _vs$i = _slicedToArray(vs[i], 2),\n        xi = _vs$i[0],\n        yi = _vs$i[1];\n\n    var _vs$j = _slicedToArray(vs[j], 2),\n        xj = _vs$j[0],\n        yj = _vs$j[1];\n\n    var intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;\n\n    if (intersect) {\n      inside = !inside;\n    }\n  }\n\n  return inside;\n}\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nexports.computeVoxelSize = computeVoxelSize;\nexports.computeScore = computeScore;\nexports.computeIOPProjectedDistance = computeIOPProjectedDistance;\nexports.computeOverlapFactor = computeOverlapFactor;\nexports.score = score;\n\nvar _externalModules = __webpack_require__(0);\n\nvar _externalModules2 = _interopRequireDefault(_externalModules);\n\nvar _threshold = __webpack_require__(1);\n\nvar _constants = __webpack_require__(2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar getToolState = _externalModules2.default.cornerstoneTools.getToolState;\n\n\nfunction getDensityFactor(hu) {\n  if (hu < 130) {\n    return 0;\n  } else if (hu < 200) {\n    return 1;\n  } else if (hu < 300) {\n    return 2;\n  } else if (hu < 400) {\n    return 3;\n  }\n\n  return 4;\n}\n\n// Finds the value with the most occurrences in array\n// Should be O(n)\nfunction mode(array) {\n  if (array.length === 0) {\n    return null;\n  }\n  var modeMap = {};\n  var maxEl = array[0];\n  var maxCount = 1;\n\n  for (var i = 0; i < array.length; i++) {\n    var el = array[i];\n\n    if (modeMap[el] === null) {\n      modeMap[el] = 1;\n    } else {\n      modeMap[el]++;\n    }\n\n    if (modeMap[el] > maxCount) {\n      maxEl = el;\n      maxCount = modeMap[el];\n    }\n  }\n\n  return maxEl;\n}\n\nfunction computeVoxelSize(metaData) {\n  if (metaData.sliceThickness === 0 || metaData.pixelSpacing[0] === 0 || metaData.pixelSpacing[1] === 0) {\n    throw new Error('sliceThickness or pixelSpacing was 0');\n  }\n  var zLength = metaData.sliceThickness;\n  var xLength = metaData.pixelSpacing[0];\n  var yLength = metaData.pixelSpacing[1];\n\n  return zLength * xLength * yLength; // In mm\n}\n\nfunction computeScore(metaData, voxels) {\n  // Division by 3 because Agatson score assumes a slice thickness of 3 mm\n  var voxelSizeScaled = computeVoxelSize(metaData) / 3;\n  var densityFactor = getDensityFactor(metaData.maxHU);\n  var volume = voxels.length * voxelSizeScaled;\n\n  var _getConfiguration = (0, _threshold.getConfiguration)(),\n      KVPToMultiplier = _getConfiguration.KVPToMultiplier;\n\n  var KVPMultiplier = KVPToMultiplier[metaData.KVP];\n  var cascore = volume * densityFactor * KVPMultiplier;\n\n  console.log('modeOverlapFactor: ' + metaData.modeOverlapFactor);\n  console.log('voxels.length: ' + voxels.length);\n  console.log('voxelSizeScaled: ' + voxelSizeScaled);\n  console.log('Volume: ' + volume);\n  console.log('Max HU: ' + metaData.maxHU);\n  console.log('densityFactor: ' + densityFactor);\n  console.log('KVPMultiplier: ' + KVPMultiplier);\n  console.log('CAscore: ' + cascore);\n\n  // If modeOverlapFactor factor is undefined it is because there is only one slice in the series.\n  // In this case obviously modeOverlapFactor is meaningless and should not be multiplied with cascore.\n  if (metaData.modeOverlapFactor) {\n    return cascore * metaData.modeOverlapFactor;\n  }\n\n  return cascore;\n}\n\n/*\n* Computes the distance between two slices based on the DICOM Image Plane Module\n* @param imagePositions {Array[2][3]} - DICOM tag (0020, 0032) of two slices\n* @param imageOrientation {Array[2][3]} - DICOM tag (0020, 0037) of first slice\n*/\nfunction computeIOPProjectedDistance(imagePositions, imageOrientation) {\n  var imagePosition1Vector = new _externalModules2.default.cornerstoneMath.Vector3();\n\n  imagePosition1Vector.fromArray(imagePositions[0]);\n\n  var imagePosition2Vector = new _externalModules2.default.cornerstoneMath.Vector3();\n\n  imagePosition2Vector.fromArray(imagePositions[1]);\n\n  var imageOrientationRowVector = new _externalModules2.default.cornerstoneMath.Vector3();\n\n  imageOrientationRowVector.fromArray(imageOrientation[0]);\n\n  var imageOrientationColumnVector = new _externalModules2.default.cornerstoneMath.Vector3();\n\n  imageOrientationColumnVector.fromArray(imageOrientation[1]);\n\n  // Compute unit normal of Image Orientation crossVectors\n  var orientationNormal = new _externalModules2.default.cornerstoneMath.Vector3();\n\n  orientationNormal.crossVectors(imageOrientationRowVector, imageOrientationColumnVector);\n  // Project both position vectors on normal\n  var projection1 = imagePosition1Vector.projectOnVector(orientationNormal);\n  var projection2 = imagePosition2Vector.projectOnVector(orientationNormal);\n\n  // Compute distance of projected vectors\n  return projection1.distanceTo(projection2);\n}\n\nfunction computeOverlapFactor(distance, sliceThickness) {\n  if (distance <= 0) {\n    throw new Error('Distance must be > 0');\n  }\n\n  if (distance >= sliceThickness) {\n    return 1;\n  }\n\n  var overlap = sliceThickness - distance;\n\n  return (sliceThickness - overlap) / sliceThickness;\n}\n\nfunction bfs(x, y, view, visitedVoxels, label, image) {\n  var intercept = image.intercept,\n      slope = image.slope,\n      width = image.width;\n\n  var pixelData = image.getPixelData();\n  var lesionVoxels = [];\n  var stack = [[x, y]];\n\n  while (stack.length > 0) {\n    var _stack$shift = stack.shift(),\n        _stack$shift2 = _slicedToArray(_stack$shift, 2),\n        _x = _stack$shift2[0],\n        _y = _stack$shift2[1];\n\n    // If visited is 0, the element has not been visisted before\n\n\n    if (visitedVoxels[_x][_y] === 0 && view[_y * width + _x] === label) {\n      stack.push([_x - 1, _y]);\n      stack.push([_x + 1, _y]);\n      stack.push([_x, _y - 1]);\n      stack.push([_x, _y + 1]);\n\n      var value = pixelData[_x + _y * width];\n      var hu = value * slope + intercept;\n\n      if (hu >= 130) {\n        lesionVoxels.push(hu);\n      }\n      visitedVoxels[_x][_y] = 1;\n    }\n  }\n\n  return lesionVoxels;\n}\n\n/**\n * Calculate CaScore per label per slice per lesion\n *\n */\nfunction score() {\n  var element = (0, _threshold.getLastElement)();\n\n  var _getConfiguration2 = (0, _threshold.getConfiguration)(),\n      regionColorsRGB = _getConfiguration2.regionColorsRGB;\n\n  var regionsToolData = getToolState(element, _constants.TOOL_TYPE);\n  var stackToolData = getToolState(element, 'stack');\n  var buffer = regionsToolData.data[0].buffer;\n  var imageIds = stackToolData.data[0].imageIds;\n\n  // Extract and group region-voxels\n\n  var voxelsEachRegion = regionColorsRGB.slice(1).map(function () {\n    return imageIds.map(function () {\n      return [];\n    });\n  });\n  var maxHUEachRegion = regionColorsRGB.slice(1).map(function () {\n    return imageIds.map(function () {\n      return [];\n    });\n  });\n\n  var overlapFactor = void 0;\n  var prevImagePosition = void 0;\n  var overlapFactors = [];\n\n  var metaData = {};\n\n  return Promise.all(imageIds.map(function (imageId, imageIndex) {\n    return _externalModules2.default.cornerstone.loadImage(imageId).then(function (image) {\n      var dataSet = image.data;\n\n      metaData.sliceThickness = dataSet.floatString('x00180050');\n      metaData.pixelSpacing = dataSet.string('x00280030').split('\\\\').map(parseFloat);\n      metaData.KVP = dataSet.floatString('x00180060');\n      metaData.rescaleSlope = dataSet.floatString('x00281053');\n      metaData.rescaleIntercept = dataSet.floatString('x00281052');\n      metaData.rescaleType = dataSet.string('x00281054');\n\n      var imagePositionPatient = dataSet.string('x00200032').split('\\\\').map(parseFloat);\n      var imageOrientationTmp = dataSet.string('x00200037').split('\\\\').map(parseFloat);\n      var imageOrientation = [imageOrientationTmp.slice(0, 3), imageOrientationTmp.slice(3)];\n\n      /* What is this?\n       if (metaData.rescaleType !== 'HU') {\n         console.warn(`Modality LUT does not convert to Hounsfield units but to ${metaData.rescaleType}. Agatston score is not defined for this unit type.`);\n          return;\n      }\n       */\n\n      if (prevImagePosition) {\n        var distance = computeIOPProjectedDistance([prevImagePosition, imagePositionPatient], imageOrientation);\n\n        overlapFactor = computeOverlapFactor(distance, metaData.sliceThickness);\n\n        // Find overlapfactor with the highest occurance\n        overlapFactors.push(overlapFactor);\n        metaData.modeOverlapFactor = mode(overlapFactors);\n\n        // Save imagePositionPatient for next overlapFactor computation\n        prevImagePosition = imagePositionPatient;\n      } else {\n        prevImagePosition = imagePositionPatient;\n      }\n\n      // Overlap has been calculated, now we investigate voxels\n\n      var height = image.height,\n          width = image.width;\n\n      var sliceSize = width * height;\n      var offset = imageIndex * sliceSize;\n\n      var view = new _constants.TYPED_ARRAY(buffer, offset, sliceSize);\n\n      // Initialze with 0's\n      var visitedVoxels = Array(width).fill().map(function () {\n        return Array(height).fill(0);\n      });\n\n      for (var x = 0; x < width; x += 1) {\n        for (var y = 0; y < height; y += 1) {\n          // Extract label from view into ArrayBuffer\n          var label = view[y * width + x];\n\n          if (label > 1) {\n            var lesionVoxels = bfs(x, y, view, visitedVoxels, label, image);\n\n            if (lesionVoxels.length) {\n              var maxHU = Math.max.apply(Math, _toConsumableArray(lesionVoxels));\n\n              voxelsEachRegion[label - 2][imageIndex].push(lesionVoxels);\n              maxHUEachRegion[label - 2][imageIndex].push(maxHU);\n            }\n          }\n        }\n      }\n    });\n  }\n  // When all images have been processed\n  )).then(function () {\n    return voxelsEachRegion.map(function (slicesInLabel, labelIdx) {\n      var cascore = [];\n\n      slicesInLabel.forEach(function (lesions, sliceIdx) {\n        lesions.forEach(function (voxels, lesionIdx) {\n          metaData.maxHU = maxHUEachRegion[labelIdx][sliceIdx][lesionIdx];\n\n          var cascoreCurrent = voxels.length > 0 ? computeScore(metaData, voxels) : 0;\n\n          cascore.push(cascoreCurrent);\n        });\n      });\n      var sum = cascore.reduce(function (acc, val) {\n        return acc + val;\n      }, 0);\n\n      return sum;\n    });\n  });\n}\n\nexports.default = score;\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// cornerstoneLesionTools.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap f40f514588cf2a1c19d6","let cornerstone = window.cornerstone;\nlet cornerstoneTools = window.cornerstoneTools;\n\nexport default {\n  set cornerstone (cst) {\n    cornerstone = cst;\n  },\n  get cornerstone () {\n    return cornerstone;\n  },\n  set cornerstoneTools (cst) {\n    cornerstoneTools = cst;\n  },\n  get cornerstoneTools () {\n    return cornerstoneTools;\n  }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./externalModules.js","import external from '../externalModules.js';\nimport { TYPED_ARRAY, TOOL_TYPE } from './constants.js';\n\nconst { addToolState, getToolState } = external.cornerstoneTools;\n\nlet configuration = {\n  historySize: 4,\n  layersAbove: 1,\n  layersBelow: 1,\n  historyPosition: 0,\n  toolRegionValue: 2,\n  calciumThresholdHu: '-', // Placeholder until it gets set ('-' shows up nicely in text input)\n  drawAlpha: 1,\n  regionColorsRGB: [\n    [255, 0, 255],\n    [246, 193, 91],\n    [237, 148, 69],\n    [230, 103, 49],\n    [184, 74, 41],\n    [106, 58, 45]\n  ],\n  KVPToMultiplier: {\n    150: 1.06,\n    140: 1.04,\n    130: 1.02,\n    120: 1,\n    110: 0.98,\n    100: 0.96,\n    90: 0.93,\n    80: 0.89,\n    70: 0.85\n  },\n  growIterationsPerChunk: 2\n};\n\nconfiguration.calciumThresholdHuParsed = parseInt(configuration.calciumThresholdHu, 10);\n\n/**\n * Perform the thresholding on a stack\n */\nfunction performThresholding (imageIds) {\n  let width, height, view, buffer;\n\n  // Thresholding promises\n  return Promise.all(imageIds.map((imageId, imageIdIndex) =>\n    external.cornerstone.loadImage(imageId).then((image) => {\n      if (!buffer) {\n        // Initialize variables on first loaded image\n        width = image.width;\n        height = image.height;\n\n        const length = width * height * imageIds.length;\n\n        buffer = new ArrayBuffer(length);\n        view = new TYPED_ARRAY(buffer);\n      }\n\n      const { intercept, slope } = image;\n      const pixelData = image.getPixelData();\n      const sliceSize = width * height;\n\n      for (let i = 0; i < sliceSize; i++) {\n        const value = pixelData[i];\n        // Calculate hu-value\n        const hu = (value * slope) + intercept;\n        // Check against threshold\n        const label = (hu >= configuration.calciumThresholdHu) ? 1 : 0;\n        // Calculate offset within view into ArrayBufer\n        const offset = imageIdIndex * sliceSize + i;\n\n        // Finally, assign label\n        view[offset] = label;\n      }\n    })\n  // When all promises resolve, return the buffer and its dimensions\n  )).then(() => ({\n    buffer,\n    width,\n    height\n  }));\n}\n\nfunction ensureToolData (element) {\n  let regionsData;\n\n  const regionsToolData = getToolState(element, TOOL_TYPE);\n\n  if (!regionsToolData || !regionsToolData.data || !regionsToolData.data.length) {\n    regionsData = {\n      enabled: 1,\n      buffer: null,\n      width: null,\n      height: null,\n      history: [],\n      drawBuffer: null\n    };\n    addToolState(element, TOOL_TYPE, regionsData);\n  } else {\n    regionsData = regionsToolData.data[0];\n  }\n\n  return regionsData;\n}\n\nfunction threshold (element) {\n  const stackToolData = getToolState(element, 'stack');\n  console.log(\"got stack\", stackToolData);\n  if (!stackToolData || !stackToolData.data || !stackToolData.data.length) {\n    return;\n  }\n\n  const stackData = stackToolData.data[0];\n  const regionsData = ensureToolData(element);\n\n  console.log(\"ABOUT TO PERFORM\");\n\n  performThresholding(stackData.imageIds).then((regions) => {\n    // Add threshold data to tool state\n    regionsData.buffer = regions.buffer;\n    regionsData.width = regions.width;\n    regionsData.height = regions.height;\n\n    // Update the element to apply the viewport and tool changes\n    external.cornerstone.updateImage(element);\n  });\n}\n\nfunction getConfiguration () {\n  return configuration;\n}\n\nfunction setConfiguration (config) {\n  configuration = config;\n}\n\n// Module/private exports\nexport default {\n  threshold,\n  getConfiguration,\n  setConfiguration\n};\n\n\n\n// WEBPACK FOOTER //\n// ./lesionTools/threshold.js","export const TYPED_ARRAY = Uint8Array;\nexport const TOOL_TYPE = 'regions';\n\n\n\n// WEBPACK FOOTER //\n// ./lesionTools/constants.js","import external from '../externalModules.js';\n\nconst { getToolState } = external.cornerstoneTools;\n\nconst configuration = {};\n\n/**\n * Store current state to history\n */\nexport function createUndoStep (element) {\n  const thresholdingData = getToolState(element, 'regions');\n\n  const state = thresholdingData.data[0];\n  // Make a copy using .slice()\n  const current = state.buffer.slice();\n\n  // Put at end of history\n  state.history.push(current);\n  // Remove oldest if too much history\n  if (state.history.length > configuration.historySize) {\n    state.history.shift();\n  }\n}\n\nexport function undo (element) {\n  const thresholdingData = getToolState(element, 'regions');\n  const state = thresholdingData.data[0];\n\n  if (state.history.length < 1) {\n    return;\n  }\n\n  const replacement = state.history.pop();\n\n  state.buffer = replacement;\n  external.cornerstone.updateImage(element);\n}\n\nexport function redo () {\n  // Not implemented\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lesionTools/history.js","export { default as external } from './externalModules.js';\nexport { default as display } from './lesionTools/display.js';\nexport { default as threshold } from './lesionTools/threshold.js';\nexport { default as grow } from './lesionTools/grow.js';\nexport { default as draw } from './lesionTools/draw.js';\nexport { default as score } from './lesionTools/score.js';\nexport { undo, redo } from './lesionTools/history.js';\n\n\n\n// WEBPACK FOOTER //\n// ./index.js","import external from '../externalModules.js';\nimport { TYPED_ARRAY } from './constants.js';\n\nconst { displayTool, getToolState } = external.cornerstoneTools;\n\nconst configuration = {\n  drawAlpha: 1,\n  regionColorsRGB: [\n    [255, 0, 255],\n    [246, 193, 91],\n    [237, 148, 69],\n    [230, 103, 49],\n    [184, 74, 41],\n    [106, 58, 45]\n  ]\n};\n\n/**\n * Draw regions on image\n */\nfunction onImageRendered ({ detail }) {\n  const { canvasContext, element, enabledElement, image } = detail;\n  const { width, height } = image;\n\n  const stackToolData = getToolState(element, 'stack');\n  const regionsToolData = getToolState(element, 'regions');\n\n  // Ensure tool is enabled\n  if (!regionsToolData || !regionsToolData.data || !regionsToolData.data.length) {\n    return;\n  }\n\n  if (!regionsToolData.data[0].drawBuffer || width !== regionsToolData.data[0].drawBuffer.canvas.width) {\n    const canvas = document.createElement('canvas');\n    const context = canvas.getContext('2d');\n    const imageData = context.createImageData(width, height);\n\n    canvas.width = width;\n    canvas.height = height;\n\n    regionsToolData.data[0].drawBuffer = {\n      canvas,\n      imageData\n    };\n  }\n\n  // Extract tool data\n  const { currentImageIdIndex } = stackToolData.data[0];\n  const { drawBuffer, buffer } = regionsToolData.data[0];\n\n  const doubleBuffer = drawBuffer.canvas;\n  const imageData = drawBuffer.imageData;\n\n  const pixels = imageData.data;\n  const sliceSize = width * height;\n  const sliceOffset = currentImageIdIndex * sliceSize;\n  const view = new TYPED_ARRAY(buffer, sliceOffset, sliceSize);\n\n  for (let offset = 0; offset < view.length; offset += 1) {\n    // Each pixel is represented by four elements in the imageData array\n    const imageDataOffset = offset * 4;\n    const label = view[offset];\n\n    if (label) {\n      const color = configuration.regionColorsRGB[label - 1];\n\n      pixels[imageDataOffset + 0] = color[0];\n      pixels[imageDataOffset + 1] = color[1];\n      pixels[imageDataOffset + 2] = color[2];\n      pixels[imageDataOffset + 3] = configuration.drawAlpha * 255;\n    } else {\n      pixels[imageDataOffset + 3] = 0;\n    }\n  }\n\n  // Put image data back into offscreen canvas\n  doubleBuffer.getContext('2d').putImageData(imageData, 0, 0);\n  // Set transforms based on zoom/pan/etc\n  external.cornerstone.setToPixelCoordinateSystem(enabledElement, canvasContext);\n  // Finally, draw offscreen canvas onto context\n  canvasContext.drawImage(doubleBuffer, 0, 0);\n}\n\nconst lesionIndicator = displayTool(onImageRendered);\n\nlesionIndicator.setConfiguration(configuration);\n\nexport default lesionIndicator;\n\n\n\n// WEBPACK FOOTER //\n// ./lesionTools/display.js","import external from '../externalModules.js';\nimport { createUndoStep } from './history.js';\nimport threshold from './threshold.js';\n\nconst {\n  getToolState,\n  simpleMouseButtonTool,\n  isMouseButtonEnabled,\n  getToolOptions\n} = external.cornerstoneTools;\n\nconst toolType = 'regionsGrow';\n\n// Get neighbour linear indices within slice bounds\nfunction linearNeighbours (width, height, highSlice, lowSlice, index) {\n  const sliceSize = width * height;\n  const neighbours = [\n    index - 1,\n    index + 1,\n    index - width,\n    index + width\n  ];\n\n  // Stay within bounds\n  const sliceIndex = Math.floor(index / sliceSize);\n\n  if (sliceIndex < highSlice) {\n    neighbours.push(index + sliceSize);\n  }\n  if (sliceIndex > lowSlice) {\n    neighbours.push(index - sliceSize);\n  }\n\n  return neighbours;\n}\n\nfunction regionGrowing (regions, point) {\n  const { growIterationsPerChunk, toolRegionValue, layersAbove, layersBelow } = threshold.getConfiguration();\n  const { width, height, buffer } = regions;\n  const [x, y, slice] = point;\n  const highSlice = slice + layersBelow;\n  const lowSlice = slice - layersAbove;\n\n  const view = new Uint8Array(buffer);\n\n  // Calculate linear indices and offsets\n  const sliceSize = width * height;\n  const sliceOffset = sliceSize * slice;\n  const clickIndex = (y * width) + x;\n  const linearIndex = sliceOffset + clickIndex;\n  const fromValue = view[linearIndex];\n\n  // Only continue if we clicked in thresholded area in different color\n  if (fromValue === 0 || fromValue === toolRegionValue) {\n    return Promise.resolve();\n  }\n\n  // Growing starts at clicked voxel\n  let activeVoxels = [linearIndex];\n\n  return new Promise((resolve) => {\n    function chunk () {\n      for(let i = 0; i < growIterationsPerChunk; i++) {\n        // While activeVoxels is not empty\n        if (activeVoxels.length === 0) {\n          return resolve();\n        }\n\n        // Set the active voxels to nextValue\n        activeVoxels.forEach((i) => {\n          view[i] = toolRegionValue;\n        });\n\n        // The new active voxels are neighbours of curent active voxels\n        const nextVoxels = activeVoxels.map(\n          (i) => linearNeighbours(width, height, highSlice, lowSlice, i)\n        ).reduce( // Flatten the array of arrays to array of indices\n          (acc, cur) => acc.concat(cur), []\n        ).filter( // Remove duplicates\n          (value, index, self) => self.indexOf(value) === index\n        ).filter( // Remove voxels that does not have the correct fromValue\n          (i) => view[i] === fromValue\n        );\n\n        activeVoxels = nextVoxels;\n      }\n      setTimeout(chunk, 0);\n    }\n\n    chunk();\n  });\n}\n\nfunction mouseDownCallback (e) {\n  const { currentPoints, element, which } = e.detail;\n  const options = getToolOptions(toolType, element);\n\n  if (isMouseButtonEnabled(which, options.mouseButtonMask)) {\n    const [stackData] = getToolState(element, 'stack').data;\n    const [regionsData] = getToolState(element, 'regions').data;\n    const { currentImageIdIndex } = stackData;\n    const { x, y } = currentPoints.image;\n    const point = [Math.round(x), Math.round(y), currentImageIdIndex];\n\n    createUndoStep(element);\n    regionGrowing(regionsData, point).then(() => {\n      external.cornerstone.updateImage(element);\n    });\n  }\n}\n\nconst grow = simpleMouseButtonTool(mouseDownCallback, toolType);\n\nexport default grow;\n\n\n\n// WEBPACK FOOTER //\n// ./lesionTools/grow.js","import external from '../externalModules.js';\nimport { createUndoStep } from './history.js';\nimport pointInsidePolygon from '../util/pointInsidePolygon.js';\nimport threshold from './threshold.js';\n\nconst { getToolState, getToolOptions, setToolOptions, simpleMouseButtonTool, isMouseButtonEnabled } = external.cornerstoneTools;\n\nconst toolType = 'draw';\n\nlet configuration = {\n  snap: false, // Snap to thresholded region or not\n  fillStyle: 'rgba(255,255,255,.2)',\n  strokeStyle: 'white'\n};\n\nfunction updateRegions (element) {\n  const { toolRegionValue, layersAbove, layersBelow } = threshold.getConfiguration();\n\n  createUndoStep(element);\n\n  // Get tool data\n  const stackData = getToolState(element, 'stack');\n  const thresholdingData = getToolState(element, 'regions');\n  const options = getToolOptions(toolType, element);\n\n  // Extract tool data\n  const slice = stackData.data[0].currentImageIdIndex;\n  const numSlices = stackData.data[0].imageIds.length;\n  const regions = thresholdingData.data[0];\n\n  // Extract region data\n  const buffer = regions.buffer;\n  const width = regions.width;\n  const height = regions.height;\n\n  // Find operation bounds\n  const startSlice = Math.max(0, slice - layersAbove);\n  const endSlice = Math.min(numSlices, slice + layersBelow);\n\n  // Setup view into buffer\n  const sliceSize = width * height;\n  const sliceOffset = startSlice * sliceSize;\n  const view = new Uint8Array(buffer, sliceOffset);\n\n  // Mark points inside\n  console.log(numSlices);\n  for (let dslice = 0; dslice <= endSlice - startSlice; dslice += 1) {\n    for (let x = 0; x < width; x += 1) {\n      for (let y = 0; y < height; y += 1) {\n        const index = x + (y * width) + (dslice * sliceSize);\n        const prevValue = view[index];\n\n        let snapBool;\n\n        if (configuration.snap) {\n          snapBool = prevValue > 0;\n        } else {\n          snapBool = true;\n        }\n        if (snapBool && pointInsidePolygon({ x, y }, options.points)) {\n          view[index] = toolRegionValue;\n        }\n      }\n    }\n  }\n}\n\n// Draw regions on the canvas\nfunction imageRenderedCallback (e) {\n  const { canvasContext, enabledElement, element } = e.detail;\n  const { fillStyle, strokeStyle } = draw.getConfiguration();\n\n  // Points\n  const options = getToolOptions(toolType, element);\n  const points = options.points;\n\n  if (points.length < 2) {\n    return;\n  }\n\n  // Set the canvas context to the image coordinate system\n  external.cornerstone.setToPixelCoordinateSystem(enabledElement, canvasContext);\n\n  canvasContext.fillStyle = fillStyle;\n  canvasContext.strokeStyle = strokeStyle;\n  canvasContext.beginPath();\n  canvasContext.moveTo(points[0].x, points[0].y);\n  points.slice(1).forEach(function (point) {\n    canvasContext.lineTo(point.x, point.y);\n  });\n  canvasContext.closePath();\n  canvasContext.stroke();\n  canvasContext.fill();\n}\n\nfunction dragCallback (e) {\n  const { currentPoints, element } = e.detail;\n  const options = getToolOptions(toolType, element);\n\n  options.points.push(currentPoints.image);\n  external.cornerstone.updateImage(element);\n\n  e.preventDefault();\n  e.stopPropagation();\n}\n\n// Disable drawing and tracking on mouse up also update regions\nfunction mouseUpCallback (e) {\n  const { element } = e.detail;\n\n  element.removeEventListener('cornerstonetoolsmousedrag', dragCallback);\n  element.removeEventListener('cornerstonetoolsmouseup', mouseUpCallback);\n  element.removeEventListener('cornerstonetoolsmouseclick', mouseUpCallback);\n  element.removeEventListener('cornerstoneimagerendered', imageRenderedCallback);\n\n  updateRegions(element);\n  external.cornerstone.updateImage(element);\n}\n\n// Start drawing and tracking on mouse up, also reset points array\nfunction mouseDownCallback (e) {\n  const { element, which } = e.detail;\n  const options = getToolOptions(toolType, element);\n\n  if (isMouseButtonEnabled(which, options.mouseButtonMask)) {\n    options.points = [];\n\n    setToolOptions(toolType, element, options);\n\n    element.addEventListener('cornerstonetoolsmousedrag', dragCallback);\n    element.addEventListener('cornerstonetoolsmouseup', mouseUpCallback);\n    element.addEventListener('cornerstonetoolsmouseclick', mouseUpCallback);\n    element.addEventListener('cornerstoneimagerendered', imageRenderedCallback);\n\n    e.preventDefault();\n    e.stopPropagation();\n  }\n}\n\nconst draw = simpleMouseButtonTool(mouseDownCallback, toolType);\n\ndraw.getConfiguration = () => configuration;\ndraw.setConfiguration = (config) => {\n  configuration = config;\n};\n\nexport default draw;\n\n\n\n// WEBPACK FOOTER //\n// ./lesionTools/draw.js","// Determine if a point is inside a polygon\nexport default function pointInsidePolygon (point, points) {\n  const vs = points.map(({ x, y }) => ([x, y]));\n  const { x, y } = point;\n  let inside = false;\n\n  for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {\n    const [xi, yi] = vs[i];\n    const [xj, yj] = vs[j];\n\n    const intersect = ((yi > y) !== (yj > y)) &&\n      (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n\n    if (intersect) {\n      inside = !inside;\n    }\n  }\n\n  return inside;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./util/pointInsidePolygon.js","import external from '../externalModules.js';\nimport { getConfiguration, getLastElement } from './threshold.js';\nimport { TYPED_ARRAY, TOOL_TYPE } from './constants.js';\n\nconst { getToolState } = external.cornerstoneTools;\n\nfunction getDensityFactor (hu) {\n  if (hu < 130) {\n    return 0;\n  } else if (hu < 200) {\n    return 1;\n  } else if (hu < 300) {\n    return 2;\n  } else if (hu < 400) {\n    return 3;\n  }\n\n  return 4;\n}\n\n// Finds the value with the most occurrences in array\n// Should be O(n)\nfunction mode (array) {\n  if (array.length === 0) {\n    return null;\n  }\n  const modeMap = {};\n  let maxEl = array[0];\n  let maxCount = 1;\n\n  for (let i = 0; i < array.length; i++) {\n    const el = array[i];\n\n    if (modeMap[el] === null) {\n      modeMap[el] = 1;\n    } else {\n      modeMap[el]++;\n    }\n\n    if(modeMap[el] > maxCount) {\n      maxEl = el;\n      maxCount = modeMap[el];\n    }\n  }\n\n  return maxEl;\n}\n\nexport function computeVoxelSize (metaData) {\n  if (metaData.sliceThickness === 0 ||\n      metaData.pixelSpacing[0] === 0 ||\n      metaData.pixelSpacing[1] === 0) {\n    throw new Error('sliceThickness or pixelSpacing was 0');\n  }\n  const zLength = metaData.sliceThickness;\n  const xLength = metaData.pixelSpacing[0];\n  const yLength = metaData.pixelSpacing[1];\n\n\n  return zLength * xLength * yLength; // In mm\n}\n\nexport function computeScore (metaData, voxels) {\n  // Division by 3 because Agatson score assumes a slice thickness of 3 mm\n  const voxelSizeScaled = computeVoxelSize(metaData) / 3;\n  const densityFactor = getDensityFactor(metaData.maxHU);\n  const volume = voxels.length * voxelSizeScaled;\n\n  const { KVPToMultiplier } = getConfiguration();\n  const KVPMultiplier = KVPToMultiplier[metaData.KVP];\n  const cascore = volume * densityFactor * KVPMultiplier;\n\n  console.log(`modeOverlapFactor: ${metaData.modeOverlapFactor}`);\n  console.log(`voxels.length: ${voxels.length}`);\n  console.log(`voxelSizeScaled: ${voxelSizeScaled}`);\n  console.log(`Volume: ${volume}`);\n  console.log(`Max HU: ${metaData.maxHU}`);\n  console.log(`densityFactor: ${densityFactor}`);\n  console.log(`KVPMultiplier: ${KVPMultiplier}`);\n  console.log(`CAscore: ${cascore}`);\n\n  // If modeOverlapFactor factor is undefined it is because there is only one slice in the series.\n  // In this case obviously modeOverlapFactor is meaningless and should not be multiplied with cascore.\n  if (metaData.modeOverlapFactor) {\n    return cascore * metaData.modeOverlapFactor;\n  }\n\n  return cascore;\n\n}\n\n/*\n* Computes the distance between two slices based on the DICOM Image Plane Module\n* @param imagePositions {Array[2][3]} - DICOM tag (0020, 0032) of two slices\n* @param imageOrientation {Array[2][3]} - DICOM tag (0020, 0037) of first slice\n*/\nexport function computeIOPProjectedDistance (imagePositions, imageOrientation) {\n  const imagePosition1Vector = new external.cornerstoneMath.Vector3();\n\n  imagePosition1Vector.fromArray(imagePositions[0]);\n\n  const imagePosition2Vector = new external.cornerstoneMath.Vector3();\n\n  imagePosition2Vector.fromArray(imagePositions[1]);\n\n  const imageOrientationRowVector = new external.cornerstoneMath.Vector3();\n\n  imageOrientationRowVector.fromArray(imageOrientation[0]);\n\n  const imageOrientationColumnVector = new external.cornerstoneMath.Vector3();\n\n  imageOrientationColumnVector.fromArray(imageOrientation[1]);\n\n  // Compute unit normal of Image Orientation crossVectors\n  const orientationNormal = new external.cornerstoneMath.Vector3();\n\n  orientationNormal.crossVectors(imageOrientationRowVector, imageOrientationColumnVector);\n  // Project both position vectors on normal\n  const projection1 = imagePosition1Vector.projectOnVector(orientationNormal);\n  const projection2 = imagePosition2Vector.projectOnVector(orientationNormal);\n\n  // Compute distance of projected vectors\n  return projection1.distanceTo(projection2);\n}\n\nexport function computeOverlapFactor (distance, sliceThickness) {\n  if (distance <= 0) {\n    throw new Error('Distance must be > 0');\n  }\n\n  if (distance >= sliceThickness) {\n    return 1;\n  }\n\n  const overlap = sliceThickness - distance;\n\n  return (sliceThickness - overlap) / (sliceThickness);\n}\n\nfunction bfs (x, y, view, visitedVoxels, label, image) {\n  const { intercept, slope, width } = image;\n  const pixelData = image.getPixelData();\n  const lesionVoxels = [];\n  const stack = [[x, y]];\n\n  while (stack.length > 0) {\n    const [x, y] = stack.shift();\n\n    // If visited is 0, the element has not been visisted before\n    if (visitedVoxels[x][y] === 0 && view[y * width + x] === label) {\n      stack.push([x - 1, y]);\n      stack.push([x + 1, y]);\n      stack.push([x, y - 1]);\n      stack.push([x, y + 1]);\n\n      const value = pixelData[x + y * width];\n      const hu = (value * slope) + intercept;\n\n      if (hu >= 130) {\n        lesionVoxels.push(hu);\n      }\n      visitedVoxels[x][y] = 1;\n    }\n\n  }\n\n  return lesionVoxels;\n}\n\n/**\n * Calculate CaScore per label per slice per lesion\n *\n */\nexport function score () {\n  const element = getLastElement();\n  const { regionColorsRGB } = getConfiguration();\n\n  const regionsToolData = getToolState(element, TOOL_TYPE);\n  const stackToolData = getToolState(element, 'stack');\n  const { buffer } = regionsToolData.data[0];\n  const { imageIds } = stackToolData.data[0];\n\n  // Extract and group region-voxels\n  const voxelsEachRegion = regionColorsRGB.slice(1).map(() => imageIds.map(() => []));\n  const maxHUEachRegion = regionColorsRGB.slice(1).map(() => imageIds.map(() => []));\n\n  let overlapFactor;\n  let prevImagePosition;\n  const overlapFactors = [];\n\n  const metaData = {};\n\n  return Promise.all(imageIds.map((imageId, imageIndex) =>\n    external.cornerstone.loadImage(imageId).then((image) => {\n      const dataSet = image.data;\n\n      metaData.sliceThickness = dataSet.floatString('x00180050');\n      metaData.pixelSpacing = dataSet.string('x00280030').split('\\\\').map(parseFloat);\n      metaData.KVP = dataSet.floatString('x00180060');\n      metaData.rescaleSlope = dataSet.floatString('x00281053');\n      metaData.rescaleIntercept = dataSet.floatString('x00281052');\n      metaData.rescaleType = dataSet.string('x00281054');\n\n      const imagePositionPatient = dataSet.string('x00200032').split('\\\\').map(parseFloat);\n      const imageOrientationTmp = dataSet.string('x00200037').split('\\\\').map(parseFloat);\n      const imageOrientation = [\n        imageOrientationTmp.slice(0, 3),\n        imageOrientationTmp.slice(3)\n      ];\n\n      /* What is this?\n       if (metaData.rescaleType !== 'HU') {\n         console.warn(`Modality LUT does not convert to Hounsfield units but to ${metaData.rescaleType}. Agatston score is not defined for this unit type.`);\n\n         return;\n      }\n       */\n\n      if (prevImagePosition) {\n        const distance = computeIOPProjectedDistance([prevImagePosition, imagePositionPatient], imageOrientation);\n\n        overlapFactor = computeOverlapFactor(distance, metaData.sliceThickness);\n\n        // Find overlapfactor with the highest occurance\n        overlapFactors.push(overlapFactor);\n        metaData.modeOverlapFactor = mode(overlapFactors);\n\n        // Save imagePositionPatient for next overlapFactor computation\n        prevImagePosition = imagePositionPatient;\n      } else {\n        prevImagePosition = imagePositionPatient;\n      }\n\n      // Overlap has been calculated, now we investigate voxels\n\n      const { height, width } = image;\n      const sliceSize = width * height;\n      const offset = imageIndex * sliceSize;\n\n      const view = new TYPED_ARRAY(buffer, offset, sliceSize);\n\n      // Initialze with 0's\n      const visitedVoxels = Array(width).fill().map(() => Array(height).fill(0));\n\n      for (let x = 0; x < width; x += 1) {\n        for (let y = 0; y < height; y += 1) {\n          // Extract label from view into ArrayBuffer\n          const label = view[y * width + x];\n\n          if (label > 1) {\n            const lesionVoxels = bfs(x, y, view, visitedVoxels, label, image);\n\n            if (lesionVoxels.length) {\n              const maxHU = Math.max(...lesionVoxels);\n\n              voxelsEachRegion[label - 2][imageIndex].push(lesionVoxels);\n              maxHUEachRegion[label - 2][imageIndex].push(maxHU);\n            }\n          }\n        }\n      }\n    })\n  // When all images have been processed\n  )).then(() => voxelsEachRegion.map((slicesInLabel, labelIdx) => {\n    const cascore = [];\n\n    slicesInLabel.forEach((lesions, sliceIdx) => {\n      lesions.forEach((voxels, lesionIdx) => {\n        metaData.maxHU = maxHUEachRegion[labelIdx][sliceIdx][lesionIdx];\n\n        const cascoreCurrent = voxels.length > 0 ? computeScore(metaData, voxels) : 0;\n\n        cascore.push(cascoreCurrent);\n      });\n    });\n    const sum = cascore.reduce((acc, val) => acc + val, 0);\n\n    return sum;\n  }));\n}\n\nexport default score;\n\n\n\n// WEBPACK FOOTER //\n// ./lesionTools/score.js"],"sourceRoot":""}